<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <link href="_app/immutable/assets/Toaster.DKF17Rty.css" rel="stylesheet">
    <link href="_app/immutable/assets/sonner.D-t0946E.css" rel="stylesheet">
    <link href="_app/immutable/assets/2.D8V3eyTD.css" rel="stylesheet">
    <link href="_app/immutable/assets/index.CV-KWLNP.css" rel="stylesheet">
    <style>
        .color-circle {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
            vertical-align: middle;
        }
        .color-picker-container {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Custom Color Picker Styles */
        .custom-color-picker {
            position: fixed;
            z-index: 9999;
            background: hsl(var(--card));
            border: 2px solid hsl(var(--border));
            border-radius: 16px;
            padding: 24px;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.25),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            width: 320px;
            color: hsl(var(--card-foreground));
            font-family: inherit;
            backdrop-filter: blur(8px);
        }
        
        .color-wheel {
            width: 220px;
            height: 220px;
            border-radius: 12px;
            position: relative;
            margin: 0 auto 24px;
            cursor: crosshair;
            background: 
                linear-gradient(to top, rgba(0,0,0,1) 0%, rgba(0,0,0,0) 100%),
                linear-gradient(to right, rgba(255,255,255,1) 0%, rgba(255,255,255,0) 100%),
                hsl(0, 100%, 50%);
            border: 2px solid hsl(var(--border));
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.1),
                0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        
        .color-wheel-pointer {
            position: absolute;
            width: 16px;
            height: 16px;
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 
                0 0 0 1px rgba(0, 0, 0, 0.3),
                0 2px 8px rgba(0, 0, 0, 0.25),
                inset 0 0 0 1px rgba(255, 255, 255, 0.8);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
            transition: all 0.1s ease;
        }
        
        .hue-slider {
            width: 100%;
            height: 12px;
            border-radius: 6px;
            background: linear-gradient(to right, 
                #ff0000 0%, #ffff00 16.66%, #00ff00 33.33%, 
                #00ffff 50%, #0000ff 66.66%, #ff00ff 83.33%, #ff0000 100%);
            position: relative;
            cursor: pointer;
            margin-bottom: 20px;
            border: 2px solid hsl(var(--border));
            box-shadow: 
                inset 0 1px 2px rgba(0, 0, 0, 0.1),
                0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .hue-slider-pointer {
            position: absolute;
            top: -10px;
            width: 24px;
            height: 32px;
            background: white;
            border: 2px solid hsl(var(--border));
            border-radius: 6px;
            box-shadow: 
                0 0 0 1px rgba(0, 0, 0, 0.1),
                0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateX(-50%);
            pointer-events: none;
            transition: all 0.1s ease;
        }
        
        .color-preview {
            width: 100%;
            height: 48px;
            border: 3px solid hsl(var(--border));
            border-radius: 12px;
            margin: 0 auto 20px auto;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.1),
                0 2px 8px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            display: block;
            position: relative;
            overflow: hidden;
        }
        
        .color-preview::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, transparent 50%, rgba(0,0,0,0.1) 100%);
            pointer-events: none;
        }
        
        .color-input-group {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .color-input-group .color-input-field:first-child {
            flex: 2;
        }
        
        .color-input-field {
            flex: 1;
            padding: 8px 10px;
            border: 2px solid hsl(var(--border));
            border-radius: 8px;
            font-size: 13px;
            text-align: center;
            background: hsl(var(--background));
            color: hsl(var(--foreground));
            transition: all 0.2s ease;
            min-width: 0;
            width: 100%;
            font-weight: 500;
            box-shadow: 
                inset 0 1px 2px rgba(0, 0, 0, 0.05),
                0 1px 3px rgba(0, 0, 0, 0.05);
        }
        
        /* Hide number input arrows */
        .color-input-field[type="number"]::-webkit-outer-spin-button,
        .color-input-field[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        .color-input-field[type="number"] {
            -moz-appearance: textfield;
        }
        
        .color-input-field:focus {
            outline: none;
            border-color: hsl(var(--ring));
            box-shadow: 
                0 0 0 3px hsl(var(--ring) / 0.2),
                0 1px 3px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }
        
        .color-picker-buttons {
            display: flex;
            gap: 12px;
            justify-content: space-between;
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid hsl(var(--border) / 0.5);
        }
        
        .color-picker-btn {
            padding: 10px 20px;
            border: 2px solid hsl(var(--border));
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            background: hsl(var(--secondary));
            color: hsl(var(--secondary-foreground));
            transition: all 0.2s ease;
            min-width: 80px;
        }
        
        .color-picker-btn:hover {
            background: hsl(var(--secondary) / 0.8);
        }
        
        .color-picker-btn.primary {
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border-color: hsl(var(--primary));
        }
        
        .color-picker-btn.primary:hover {
            background: hsl(var(--primary) / 0.9);
        }
        
        /* Transparency and Thickness sliders in color picker */
        .transparency-slider, .thickness-slider {
            position: relative;
            height: 8px;
            background: linear-gradient(90deg, 
                #333333 0%, 
                #2a2a2a 50%, 
                #333333 100%);
            border-radius: 4px;
            cursor: pointer;
            box-shadow: 
                inset 0 1px 2px rgba(0, 0, 0, 0.3),
                inset 0 -1px 1px rgba(255, 255, 255, 0.03),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            z-index: 10; /* Ensure slider stays above other elements */
        }
        
        /* Performance page transparency and thickness sliders */
        .transparency-slider-container, .thickness-slider-container {
            position: relative;
            height: 8px;
            background: linear-gradient(90deg, 
                #333333 0%, 
                #2a2a2a 50%, 
                #333333 100%);
            border-radius: 4px;
            cursor: pointer;
            box-shadow: 
                inset 0 1px 2px rgba(0, 0, 0, 0.3),
                inset 0 -1px 1px rgba(255, 255, 255, 0.03),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            z-index: 15; /* Higher z-index for performance sliders */
        }
        
        .transparency-slider .slider-track,
        .thickness-slider .slider-track,
        .transparency-slider-container .slider-track,
        .thickness-slider-container .slider-track {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 4px;
            overflow: hidden;
            z-index: 16;
        }
        
        .transparency-slider .slider-fill,
        .thickness-slider .slider-fill,
        .transparency-slider-container .slider-fill,
        .thickness-slider-container .slider-fill {
            height: 100%;
            background: #2a2a2a;
            border-radius: 4px;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.4),
                inset 0 -1px 2px rgba(255, 255, 255, 0.05),
                0 0 0 1px rgba(0, 0, 0, 0.6),
                0 1px 3px rgba(0, 0, 0, 0.2);
            z-index: 17;
        }
        
        .transparency-slider .slider-thumb,
        .thickness-slider .slider-thumb,
        .transparency-slider-container .slider-thumb,
        .thickness-slider-container .slider-thumb {
            position: absolute;
            top: -4px;
            width: 16px;
            height: 16px;
            background: #2a2a2a;
            border: 1px solid rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            cursor: grab;
            transform: translateX(-50%);
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.2),
                0 1px 3px rgba(0, 0, 0, 0.15),
                inset 0 2px 4px rgba(0, 0, 0, 0.4),
                inset 0 -1px 2px rgba(255, 255, 255, 0.05);
            transition: all 0.1s ease;
            z-index: 20; /* Highest z-index for thumbs to ensure visibility */
        }
        
        .transparency-slider .slider-thumb:hover,
        .thickness-slider .slider-thumb:hover,
        .transparency-slider-container .slider-thumb:hover,
        .thickness-slider-container .slider-thumb:hover {
            transform: translateX(-50%) scale(1.1);
            box-shadow: 
                0 0 0 1px rgba(0, 0, 0, 0.7),
                0 4px 12px rgba(0, 0, 0, 0.25),
                0 2px 6px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.06),
                0 0 0 3px rgba(255, 255, 255, 0.04);
            z-index: 25; /* Even higher on hover */
        }
        
        .transparency-slider .slider-thumb:active,
        .thickness-slider .slider-thumb:active,
        .transparency-slider-container .slider-thumb:active,
        .thickness-slider-container .slider-thumb:active {
            cursor: grabbing;
            transform: translateX(-50%) scale(0.95);
            z-index: 30; /* Highest when dragging */
        }
        
        /* Ensure color picker stays above main content */
        .custom-color-picker {
            z-index: 9999 !important;
        }
        
        /* Ensure main content doesn't interfere with sliders */
        .settings-content {
            position: relative;
            z-index: 1;
        }
        
        /* Slider containers get higher z-index */
        .slider-container {
            position: relative;
            z-index: 10;
        }
        
        /* Dark/Black Slider Thumb Circles */
        .slider-thumb {
            background: #2a2a2a !important;
            border: 1px solid rgba(0, 0, 0, 0.6) !important;
            border-radius: 50% !important;
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.2),
                0 1px 3px rgba(0, 0, 0, 0.15),
                inset 0 2px 4px rgba(0, 0, 0, 0.4),
                inset 0 -1px 2px rgba(255, 255, 255, 0.05) !important;
            position: relative;
        }
        
        .slider-thumb::after {
            display: none;
        }
        
        .slider-thumb::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.1) 0%, 
                transparent 50%, 
                rgba(0, 0, 0, 0.1) 100%);
            border-radius: inherit;
            pointer-events: none;
            z-index: 1;
        }
        
        .slider-thumb:hover {
            transform: scale(1.05);
            box-shadow: 
                0 0 0 1px rgba(0, 0, 0, 0.7),
                0 4px 12px rgba(0, 0, 0, 0.25),
                0 2px 6px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.06),
                0 0 0 3px rgba(255, 255, 255, 0.04) !important;
        }
        
        .slider-thumb:active,
        .slider-thumb.active\:cursor-grabbing {
            transform: scale(0.98);
            box-shadow: 
                0 0 0 1px rgba(0, 0, 0, 0.8),
                0 2px 6px rgba(0, 0, 0, 0.3),
                0 1px 3px rgba(0, 0, 0, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.02),
                0 0 0 3px rgba(255, 255, 255, 0.06) !important;
        }
        
        .slider-thumb:focus-visible {
            outline: none;
            background: linear-gradient(135deg, 
                #2a2a2a 0%, 
                #1f1f1f 50%, 
                #141414 100%) !important;
            border-color: #555555 !important;
            box-shadow: 
                0 0 0 1px rgba(0, 0, 0, 0.7),
                0 3px 10px rgba(0, 0, 0, 0.25),
                0 1px 4px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.04),
                0 0 0 3px rgba(255, 255, 255, 0.08) !important;
        }
        
        /* General Slider Container Track and Fill */
        .slider-container .slider-track {
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, 
                #333333 0%, 
                #2a2a2a 50%, 
                #333333 100%);
            border-radius: 9999px;
            position: relative;
            overflow: hidden;
            box-shadow: 
                inset 0 1px 2px rgba(0, 0, 0, 0.3),
                inset 0 -1px 1px rgba(255, 255, 255, 0.03),
                0 0 0 1px rgba(255, 255, 255, 0.1);
        }

        .slider-container .slider-fill {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: #2a2a2a;
            border-radius: 9999px;
            transition: width 0.15s ease;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.4),
                inset 0 -1px 2px rgba(255, 255, 255, 0.05),
                0 0 0 1px rgba(0, 0, 0, 0.6),
                0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .slider-container .slider-thumb {
            position: absolute;
            top: 50%;
            width: 16px;
            height: 16px;
            background: #2a2a2a;
            border: 1px solid rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            transform: translateY(-50%);
            cursor: grab;
            transition: all 0.15s ease;
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.2),
                0 1px 3px rgba(0, 0, 0, 0.15),
                inset 0 2px 4px rgba(0, 0, 0, 0.4),
                inset 0 -1px 2px rgba(255, 255, 255, 0.05);
        }

        /* Dark Slider Fill to Match Thumbs */
        .slider-fill {
            background: #2a2a2a !important;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.4),
                inset 0 -1px 2px rgba(255, 255, 255, 0.05),
                0 0 0 1px rgba(0, 0, 0, 0.6),
                0 1px 3px rgba(0, 0, 0, 0.2);
        }
        
        /* Black unfilled slider track background */
        .bg-primary\/25 {
            background: linear-gradient(90deg, 
                #333333 0%, 
                #2a2a2a 50%, 
                #333333 100%) !important;
            box-shadow: 
                inset 0 1px 2px rgba(0, 0, 0, 0.3),
                inset 0 -1px 1px rgba(255, 255, 255, 0.03),
                0 0 0 1px rgba(255, 255, 255, 0.1) !important;
            border-radius: 9999px;
        }
        
        /* Remove all scrollbars */
        * {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        *::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        
        /* Prevent text selection and dragging */
        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-user-drag: none;
            -khtml-user-drag: none;
            -moz-user-drag: none;
            -o-user-drag: none;
            user-drag: none;
        }
        
        /* Custom tab slider animation */
        .tab-slider {
            position: absolute;
            background: hsl(var(--primary));
            border-radius: 6px;
            transition: all 300ms cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 0;
            height: 36px;
            width: calc(100% - 16px);
            left: 8px;
            top: 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        
        .settings-tab {
            position: relative;
            z-index: 1;
            transition: color 200ms cubic-bezier(0.4, 0, 0.2, 1);
            background: transparent !important;
            box-shadow: none !important;
        }
        
        .settings-tab.active {
            color: hsl(var(--primary-foreground)) !important;
        }
        
        .settings-tab:not(.active) {
            color: hsl(var(--foreground));
        }
        
        /* Master toggle badges */
        .master-badge {
            display: inline-flex;
            align-items: center;
            border-radius: 4px;
            padding: 1px 6px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            margin-left: 8px;
        }
        
        /* Collapsible sections */
        .collapsible-content {
            overflow: hidden;
            transition: max-height 300ms cubic-bezier(0.4, 0, 0.2, 1), 
                        opacity 300ms cubic-bezier(0.4, 0, 0.2, 1),
                        transform 300ms cubic-bezier(0.4, 0, 0.2, 1);
            max-height: 1000px; /* Large enough to accommodate content */
            transform: translateX(0);
        }
        
        .collapsible-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
            margin-top: 0 !important;
            margin-bottom: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            transform: translateX(-12px);
        }
        
        /* Fix for master box padding when collapsed */
        .master-container-collapsed {
            padding-bottom: 1rem !important; /* Keep consistent with top/sides padding */
            margin-bottom: 1rem !important; /* Maintain consistent spacing to prevent upward shift */
        }
        
        /* Better spacing for collapsed content areas */
        .collapsible-content.collapsed {
            margin-bottom: 0 !important; /* Remove any bottom margin when collapsed */
        }
        
        .collapse-indicator {
            transition: transform 300ms cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
        }
        
        .collapse-indicator.collapsed {
            transform: rotate(-90deg);
        }
        
        /* Tab container for slider */
        .tab-container {
            position: relative;
            padding: 4px;
        }
        
        /* Toast notifications positioning */
        .toast-container {
            position: fixed;
            top: 60px; /* Below the green status bar */
            right: 20px;
            z-index: 10000;
            pointer-events: none;
        }
        
        .toast {
            pointer-events: auto;
            margin-bottom: 8px;
        }
        
        /* Page fade transition */
        .page-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: hsl(var(--background));
            z-index: 9999;
            opacity: 1;
            pointer-events: all;
            transition: opacity 400ms cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .page-transition.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .page-content {
            opacity: 0;
            transition: opacity 400ms cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .page-content.fade-out {
            opacity: 0;
        }
    </style>
    
    <script>
        (function setInitialMode({ defaultMode = "system", themeColors: themeColors2, darkClassNames: darkClassNames2 = ["dark"], lightClassNames: lightClassNames2 = [], defaultTheme = "", modeStorageKey: modeStorageKey2 = "mode-watcher-mode", themeStorageKey: themeStorageKey2 = "mode-watcher-theme" }) {
            const rootEl = document.documentElement;
            const mode = localStorage.getItem(modeStorageKey2) || defaultMode;
            const theme2 = localStorage.getItem(themeStorageKey2) || defaultTheme;
            const light = mode === "light" || mode === "system" && window.matchMedia("(prefers-color-scheme: light)").matches;
            if (light) {
                if (darkClassNames2.length)
                    rootEl.classList.remove(...darkClassNames2);
                if (lightClassNames2.length)
                    rootEl.classList.add(...lightClassNames2);
            } else {
                if (lightClassNames2.length)
                    rootEl.classList.remove(...lightClassNames2);
                if (darkClassNames2.length)
                    rootEl.classList.add(...darkClassNames2);
            }
            rootEl.style.colorScheme = light ? "light" : "dark";
            if (themeColors2) {
                const themeMetaEl = document.querySelector('meta[name="theme-color"]');
                if (themeMetaEl) {
                    themeMetaEl.setAttribute("content", mode === "light" ? themeColors2.light : themeColors2.dark);
                }
            }
            if (theme2) {
                rootEl.setAttribute("data-theme", theme2);
                localStorage.setItem(themeStorageKey2, theme2);
            }
            localStorage.setItem(modeStorageKey2, mode);
        })({ "defaultMode": "dark", "darkClassNames": ["dark"], "lightClassNames": [], "defaultTheme": "", "modeStorageKey": "mode-watcher-mode", "themeStorageKey": "mode-watcher-theme" });
    </script>
</head>
<body class="dark" data-sveltekit-preload-data="hover">
    <!-- Page transition overlay -->
    <div class="page-transition" id="pageTransition"></div>
    
    <div style="display: contents" class="page-content" id="pageContent">
        <div class="min-h-screen flex flex-col svelte-vavj46">
            <main class="flex-1 svelte-vavj46">
                <!-- Session Status Banner -->
                <div class="bg-green-100 dark:bg-green-950 border-b border-green-200 dark:border-green-800">
                    <div class="container py-2 px-4 flex items-center justify-between">
                        <div class="flex items-center gap-2 text-green-800 dark:text-green-400">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4">
                                <circle cx="12" cy="12" r="10"></circle>
                                <path d="M9 12l2 2 4-4"></path>
                            </svg>
                            <span class="text-sm font-medium">Active</span>
                        </div>
                        <a href="#" onclick="navigateToLoader(); return false;" class="text-sm text-green-800 dark:text-green-400 no-underline hover:text-green-600 dark:hover:text-green-200 font-medium">Return to Loader</a>
                    </div>
                </div>
                
                <div class="flex items-center justify-center" style="height: calc(100vh - 60px);">
                    <div class="bg-card text-card-foreground rounded-xl w-full max-w-4xl border shadow-sm grid grid-cols-[200px_1fr] overflow-hidden" style="height: 420px;">
                        <!-- Sidebar Navigation -->
                        <div class="border-r bg-muted/10 h-full">
                            <div class="p-4 pt-6 h-full flex flex-col">
                                <h3 class="font-semibold text-sm text-center mb-6 opacity-60">Settings</h3>
                                
                                <div class="tab-container space-y-2">
                                    <div class="tab-slider" id="tabSlider"></div>
                                    
                                    <button class="settings-tab focus-visible:ring-ring inline-flex items-center gap-2 whitespace-nowrap font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 rounded-md px-3 w-full justify-start text-sm h-9 active" type="button" data-tab="visuals">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2 h-4 w-4">
                                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                            <circle cx="12" cy="12" r="3"></circle>
                                        </svg>
                                        Visuals
                                    </button>
                                    
                                    <button class="settings-tab focus-visible:ring-ring inline-flex items-center gap-2 whitespace-nowrap font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 rounded-md px-3 w-full justify-start text-sm h-9" type="button" data-tab="performance">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2 h-4 w-4">
                                            <polygon points="13,2 3,14 12,14 11,22 21,10 12,10"></polygon>
                                        </svg>
                                        Performance
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Settings Content -->
                        <div class="p-5 relative h-full overflow-y-auto">
                            <!-- Visuals Settings -->
                            <div id="visuals-settings" class="settings-content space-y-4">
                                <div>
                                    <h2 class="text-lg font-semibold mb-3">Visual Settings</h2>
                                    
                                    <!-- Player ESP Master Dropdown -->
                                    <div class="space-y-4">
                                        <div class="border rounded-lg p-4 space-y-4">
                                            <div class="flex items-center justify-between cursor-pointer" data-collapsible="player-esp">
                                                <div class="space-y-1">
                                                    <div class="flex items-center gap-2">
                                                        <svg class="collapse-indicator w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                                                        </svg>
                                                        <label class="text-sm font-medium">Player ESP</label>
                                                        <span class="master-badge">Master</span>
                                                    </div>
                                                    <p class="text-xs text-muted-foreground">Enable ESP for players</p>
                                                </div>
                                                <button class="toggle-switch master-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-group="player-esp" id="player-esp-master">
                                                    <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                </button>
                                            </div>
                                            
                                            <!-- Player ESP Children -->
                                            <div class="collapsible-content ml-4 space-y-3 player-esp-children" id="player-esp-content" style="opacity: 0.5; pointer-events: none;">
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <label class="text-sm font-medium">Skeleton ESP</label>
                                                        <p class="text-xs text-muted-foreground">Show player bone structure</p>
                                                    </div>
                                                    <div class="flex items-center gap-2">
                                                        <div class="color-picker-container relative">
                                                            <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #3b82f6;" data-feature="skeleton" data-color="#3b82f6"></button>
                                                        </div>
                                                        <button class="toggle-switch child-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-group="player-esp" data-feature="skeleton" id="skeleton-esp-toggle">
                                                            <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                        </button>
                                                    </div>
                                                </div>
                                                
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <div class="flex items-center gap-2">
                                                            <label class="text-sm font-medium">Box ESP</label>
                                                            <select class="bg-background border border-input rounded-md px-2 py-1 text-xs" data-setting="box-type">
                                                                <option value="2d">2D</option>
                                                                <option value="3d">3D</option>
                                                            </select>
                                                        </div>
                                                        <p class="text-xs text-muted-foreground">2D or 3D bounding boxes</p>
                                                    </div>
                                                    <div class="flex items-center gap-2">
                                                        <div class="color-picker-container relative">
                                                            <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #ef4444;" data-feature="box" data-color="#ef4444"></button>
                                                        </div>
                                                        <button class="toggle-switch child-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-group="player-esp" data-feature="box">
                                                            <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                        </button>
                                                    </div>
                                                </div>
                                                
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <label class="text-sm font-medium">Chams</label>
                                                        <p class="text-xs text-muted-foreground">See-through player highlighting</p>
                                                    </div>
                                                    <div class="flex items-center gap-2">
                                                        <div class="color-picker-container relative">
                                                            <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #10b981;" data-feature="chams" data-color="#10b981"></button>
                                                        </div>
                                                        <button class="toggle-switch child-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-group="player-esp">
                                                            <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                        </button>
                                                    </div>
                                                </div>
                                                
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <label class="text-sm font-medium">Health ESP</label>
                                                        <p class="text-xs text-muted-foreground">Player health bar indicators</p>
                                                    </div>
                                                    <div class="flex items-center gap-2">
                                                        <div class="color-picker-container relative">
                                                            <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #f59e0b;" data-feature="health" data-color="#f59e0b"></button>
                                                        </div>
                                                        <button class="toggle-switch child-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-group="player-esp">
                                                            <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                        </button>
                                                    </div>
                                                </div>
                                                
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <label class="text-sm font-medium">Name / Operator ESP</label>
                                                        <p class="text-xs text-muted-foreground">Display player names and operators</p>
                                                    </div>
                                                    <button class="toggle-switch child-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-group="player-esp">
                                                        <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                    </button>
                                                </div>
                                                
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <label class="text-sm font-medium">Distance ESP</label>
                                                        <p class="text-xs text-muted-foreground">Show distance to players in meters</p>
                                                    </div>
                                                    <button class="toggle-switch child-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-group="player-esp">
                                                        <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                    </button>
                                                </div>
                                                
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <label class="text-sm font-medium">Visibility Check</label>
                                                        <p class="text-xs text-muted-foreground">Only show ESP for visible players</p>
                                                    </div>
                                                    <button class="toggle-switch child-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-group="player-esp">
                                                        <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                    </button>
                                                </div>
                                                
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <label class="text-sm font-medium">Spectator Detection</label>
                                                        <p class="text-xs text-muted-foreground">Advanced spectator monitoring with threat assessment</p>
                                                    </div>
                                                    <button class="toggle-switch child-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-group="player-esp" data-feature="spectator-detection" id="spectator-detection-toggle">
                                                        <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                    </button>
                                                </div>
                                                
                                                <!-- Advanced Spectator Options -->
                                                <div class="ml-4 space-y-3 spectator-options" id="spectator-options" style="opacity: 0.5; pointer-events: none;">
                                                    <div class="flex items-center justify-between">
                                                        <div class="space-y-1">
                                                            <label class="text-sm font-medium">Threat Level Display</label>
                                                            <p class="text-xs text-muted-foreground">Show threat indicators for spectators</p>
                                                        </div>
                                                        <button class="toggle-switch child-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-feature="spectator-threat-display">
                                                            <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                        </button>
                                                    </div>
                                                    
                                                    <div class="flex items-center justify-between">
                                                        <div class="space-y-1">
                                                            <label class="text-sm font-medium">Duration Tracking</label>
                                                            <p class="text-xs text-muted-foreground">Show how long each player has been spectating</p>
                                                        </div>
                                                        <button class="toggle-switch child-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-feature="spectator-duration">
                                                            <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                        </button>
                                                    </div>
                                                    
                                                    <div class="flex items-center justify-between">
                                                        <div class="space-y-1">
                                                            <label class="text-sm font-medium">Camera Type Display</label>
                                                            <p class="text-xs text-muted-foreground">Show spectator camera mode (FPS/TPS/FreeCam)</p>
                                                        </div>
                                                        <button class="toggle-switch child-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-feature="spectator-camera-type">
                                                            <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                        </button>
                                                    </div>
                                                    
                                                    <div class="flex items-center justify-between">
                                                        <div class="space-y-1">
                                                            <label class="text-sm font-medium">Suspicious Behavior Alerts</label>
                                                            <p class="text-xs text-muted-foreground">Highlight unusual spectating patterns</p>
                                                        </div>
                                                        <button class="toggle-switch child-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-feature="spectator-suspicious-alerts">
                                                            <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                        </button>
                                                    </div>
                                                </div>
                                                
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <label class="text-sm font-medium">Ignore Team</label>
                                                        <p class="text-xs text-muted-foreground">Filter out teammates from ESP</p>
                                                    </div>
                                                    <button class="toggle-switch child-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-group="player-esp">
                                                        <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <!-- Gadget ESP Dropdown -->
                                        <div class="border rounded-lg p-4 space-y-4">
                                            <div class="flex items-center justify-between cursor-pointer" data-collapsible="gadget-esp">
                                                <div class="space-y-1">
                                                    <div class="flex items-center gap-2">
                                                        <svg class="collapse-indicator w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                                                        </svg>
                                                        <label class="text-sm font-medium">Gadget ESP</label>
                                                        <span class="master-badge">Master</span>
                                                    </div>
                                                    <p class="text-xs text-muted-foreground">ESP for gadgets and equipment</p>
                                                </div>
                                                <button class="toggle-switch master-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-group="gadget-esp" id="gadget-esp-master">
                                                    <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                </button>
                                            </div>
                                            
                                            <div class="collapsible-content ml-4 space-y-3 gadget-esp-children" id="gadget-esp-content" style="opacity: 0.5; pointer-events: none;">
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <label class="text-sm font-medium">Trap ESP</label>
                                                        <p class="text-xs text-muted-foreground">Kapkan, Lesion, Aruni, etc.</p>
                                                    </div>
                                                    <div class="flex items-center gap-2">
                                                        <div class="color-picker-container relative">
                                                            <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #ef4444;" data-feature="traps" data-color="#ef4444"></button>
                                                        </div>
                                                        <button class="toggle-switch child-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-group="gadget-esp" data-feature="traps" id="trap-esp-toggle">
                                                            <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                        </button>
                                                    </div>
                                                </div>
                                                
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <label class="text-sm font-medium">Camera ESP</label>
                                                        <p class="text-xs text-muted-foreground">Default, bulletproof, Valkyrie cams</p>
                                                    </div>
                                                    <div class="flex items-center gap-2">
                                                        <div class="color-picker-container relative">
                                                            <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #10b981;" data-feature="cameras" data-color="#10b981"></button>
                                                        </div>
                                                        <button class="toggle-switch child-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-group="gadget-esp" data-feature="cameras" id="camera-esp-toggle">
                                                            <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                        </button>
                                                    </div>
                                                </div>
                                                
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <label class="text-sm font-medium">Drone ESP</label>
                                                        <p class="text-xs text-muted-foreground">Standard + Twitch drones</p>
                                                    </div>
                                                    <div class="flex items-center gap-2">
                                                        <div class="color-picker-container relative">
                                                            <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #3b82f6;" data-feature="drones" data-color="#3b82f6"></button>
                                                        </div>
                                                        <button class="toggle-switch focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false">
                                                            <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                        </button>
                                                    </div>
                                                </div>
                                                
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <label class="text-sm font-medium">Hatch / Destructible ESP</label>
                                                        <p class="text-xs text-muted-foreground">Breakable walls, hatches, barricades</p>
                                                    </div>
                                                    <div class="flex items-center gap-2">
                                                        <div class="color-picker-container relative">
                                                            <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #f59e0b;" data-feature="destructibles" data-color="#f59e0b"></button>
                                                        </div>
                                                        <button class="toggle-switch focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false">
                                                            <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                        </button>
                                                    </div>
                                                </div>
                                                
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <label class="text-sm font-medium">Breaching Charge ESP</label>
                                                        <p class="text-xs text-muted-foreground">Fuze clusters, exothermic charges</p>
                                                    </div>
                                                    <div class="flex items-center gap-2">
                                                        <div class="color-picker-container relative">
                                                            <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #f97316;" data-feature="breaching" data-color="#f97316"></button>
                                                        </div>
                                                        <button class="toggle-switch focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false">
                                                            <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                        </button>
                                                    </div>
                                                </div>
                                                
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <label class="text-sm font-medium">Icons</label>
                                                        <p class="text-xs text-muted-foreground">Draw gadget icons instead of boxes</p>
                                                    </div>
                                                    <button class="toggle-switch child-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-feature="icons" data-group="gadget-esp" id="icons-toggle">
                                                        <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                    </button>
                                                </div>
                                                
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <label class="text-sm font-medium">Names</label>
                                                        <p class="text-xs text-muted-foreground">Overlay textual gadget names</p>
                                                    </div>
                                                    <button class="toggle-switch child-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-feature="names" data-group="gadget-esp" id="names-toggle">
                                                        <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <!-- Environment ESP Dropdown -->
                                        <div class="border rounded-lg p-4 space-y-4">
                                            <div class="flex items-center justify-between cursor-pointer" data-collapsible="environment-esp">
                                                <div class="space-y-1">
                                                    <div class="flex items-center gap-2">
                                                        <svg class="collapse-indicator w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                                                        </svg>
                                                        <label class="text-sm font-medium">Environment</label>
                                                        <span class="master-badge">Master</span>
                                                    </div>
                                                    <p class="text-xs text-muted-foreground">Environmental ESP elements</p>
                                                </div>
                                                <button class="toggle-switch master-toggle focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-group="environment-esp">
                                                    <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                </button>
                                            </div>
                                            
                                            <div class="collapsible-content ml-4 space-y-3 environment-esp-children" id="environment-esp-content" style="opacity: 0.5; pointer-events: none;">
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <label class="text-sm font-medium">Objective ESP</label>
                                                        <p class="text-xs text-muted-foreground">Bomb, hostage, secure zone markers</p>
                                                    </div>
                                                    <div class="flex items-center gap-2">
                                                        <div class="color-picker-container relative">
                                                            <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #8b5cf6;" data-feature="objectives" data-color="#8b5cf6"></button>
                                                        </div>
                                                        <button class="toggle-switch focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false">
                                                            <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                        </button>
                                                    </div>
                                                </div>
                                                
                                                <div class="flex items-center justify-between">
                                                    <div class="space-y-1">
                                                        <label class="text-sm font-medium">Bomb Timer</label>
                                                        <p class="text-xs text-muted-foreground">Plant/defuse countdown overlay</p>
                                                    </div>
                                                    <button class="toggle-switch focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false">
                                                        <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Player Settings -->
                            <div id="player-settings" class="settings-content space-y-4" style="display: none;">
                                <div>
                                    <h2 class="text-lg font-semibold mb-3">Player Settings</h2>
                                    
                                    <div class="space-y-4">
                                        <div class="flex items-center justify-between">
                                            <div class="space-y-1">
                                                <div class="flex items-center gap-2">
                                                    <label class="text-sm font-medium">Health Bar</label>
                                                </div>
                                                <p class="text-xs text-muted-foreground">Show player health</p>
                                            </div>
                                            <div class="flex items-center gap-2">
                                                <div class="color-picker-container relative">
                                                    <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #10b981;" data-feature="healthbar" data-color="#10b981"></button>
                                                </div>
                                                <button class="toggle-switch focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" id="health-bar-toggle">
                                                    <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <div class="flex items-center justify-between">
                                            <div class="space-y-1">
                                                <div class="flex items-center gap-2">
                                                    <label class="text-sm font-medium">Bounding Box</label>
                                                </div>
                                                <p class="text-xs text-muted-foreground">Show player bounds</p>
                                            </div>
                                            <div class="flex items-center gap-2">
                                                <div class="color-picker-container relative">
                                                    <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #ef4444;" data-feature="boundingbox" data-color="#ef4444"></button>
                                                </div>
                                                <button class="toggle-switch focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false">
                                                    <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <div class="flex items-center justify-between">
                                            <div class="space-y-1">
                                                <div class="flex items-center gap-2">
                                                    <label class="text-sm font-medium">Head Circle</label>
                                                </div>
                                                <p class="text-xs text-muted-foreground">Show head indicator</p>
                                            </div>
                                            <div class="flex items-center gap-2">
                                                <div class="color-picker-container relative">
                                                    <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #3b82f6;" data-feature="headcircle" data-color="#3b82f6"></button>
                                                </div>
                                                <button class="toggle-switch focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false">
                                                    <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <div class="flex items-center justify-between">
                                            <div class="space-y-1">
                                                <div class="flex items-center gap-2">
                                                    <label class="text-sm font-medium">Skeleton</label>
                                                </div>
                                                <p class="text-xs text-muted-foreground">Show player skeleton</p>
                                            </div>
                                            <div class="flex items-center gap-2">
                                                <div class="color-picker-container relative">
                                                    <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #3b82f6;" data-feature="skeleton-alt" data-color="#3b82f6"></button>
                                                </div>
                                                <button class="toggle-switch focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-feature="skeleton-alt" id="skeleton-toggle-2">
                                                    <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <div class="health-bar-divider" style="display: none;">
                                            <hr class="my-4 border-t border-border">
                                        </div>
                                        <div class="health-bar-position space-y-3" style="display: none;">
                                            <div class="flex items-center justify-between">
                                                <label class="text-sm font-medium">Health Bar Position</label>
                                                <select class="bg-background border border-input rounded-md px-3 py-1 text-sm">
                                                    <option>Top</option>
                                                    <option>Bottom</option>
                                                    <option>Left</option>
                                                    <option>Right</option>
                                                </select>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Gadget Settings -->
                            <div id="gadget-settings" class="settings-content space-y-4" style="display: none;">
                                <div>
                                    <h2 class="text-lg font-semibold mb-3">Gadget Settings</h2>
                                    <div class="space-y-4">
                                        <div class="flex items-center justify-between">
                                            <div class="space-y-1">
                                                <div class="flex items-center gap-2">
                                                    <label class="text-sm font-medium">Throwables</label>
                                                </div>
                                            </div>
                                            <div class="flex items-center gap-2">
                                                <div class="color-picker-container relative">
                                                    <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #f97316;" data-feature="throwables" data-color="#f97316"></button>
                                                </div>
                                                <button class="toggle-switch focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false">
                                                    <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <div class="flex items-center justify-between">
                                            <div class="space-y-1">
                                                <div class="flex items-center gap-2">
                                                    <label class="text-sm font-medium">Traps</label>
                                                </div>
                                            </div>
                                            <div class="flex items-center gap-2">
                                                <div class="color-picker-container relative">
                                                    <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #ef4444;" data-feature="traps" data-color="#ef4444"></button>
                                                </div>
                                                <button class="toggle-switch focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-feature="traps" id="traps-duplicate-toggle">
                                                    <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <div class="flex items-center justify-between">
                                            <div class="space-y-1">
                                                <div class="flex items-center gap-2">
                                                    <label class="text-sm font-medium">Cameras</label>
                                                </div>
                                            </div>
                                            <div class="flex items-center gap-2">
                                                <div class="color-picker-container relative">
                                                    <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #10b981;" data-feature="cameras" data-color="#10b981"></button>
                                                </div>
                                                <button class="toggle-switch focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false" data-feature="cameras" id="cameras-duplicate-toggle">
                                                    <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <div class="flex items-center justify-between">
                                            <div class="space-y-1">
                                                <div class="flex items-center gap-2">
                                                    <label class="text-sm font-medium">Utils</label>
                                                </div>
                                            </div>
                                            <div class="flex items-center gap-2">
                                                <div class="color-picker-container relative">
                                                    <button class="color-circle w-5 h-5 rounded-full border-2 border-gray-300 dark:border-gray-600 cursor-pointer transition-all hover:scale-110" style="background-color: #3b82f6;" data-feature="utils" data-color="#3b82f6"></button>
                                                </div>
                                                <button class="toggle-switch focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-primary data-[state=unchecked]:bg-input peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 h-5 w-9" data-state="unchecked" role="switch" aria-checked="false">
                                                    <span class="toggle-thumb bg-background pointer-events-none block rounded-full shadow-lg ring-0 transition-transform data-[state=unchecked]:translate-x-0 size-4 data-[state=checked]:translate-x-4" data-state="unchecked"></span>
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Performance Settings -->
                            <div id="performance-settings" class="settings-content space-y-4" style="display: none;">
                                <div>
                                    <h2 class="text-lg font-semibold mb-3">Performance Settings</h2>
                                    
                                    <div class="space-y-4">
                        <!-- Overlay FPS Slider -->
                        <div class="border rounded-lg p-4">
                            <div class="flex items-center justify-between mb-3">
                                <div>
                                    <label class="text-sm font-medium">Overlay FPS</label>
                                    <p class="text-xs text-muted-foreground">Control ESP rendering frame rate</p>
                                </div>
                                <span class="text-sm font-medium" id="overlayFpsValue">60 FPS</span>
                            </div>
                            <div class="slider-container" id="overlayFpsSlider" data-min="30" data-max="144" data-value="60" data-step="1" data-precision="0" data-slider-key="overlayFpsSlider" data-performance-setting="fps">
                                <div class="slider-track">
                                    <div class="slider-fill"></div>
                                    <div class="slider-thumb" tabindex="0" role="slider" aria-valuemin="30" aria-valuemax="144" aria-valuenow="60" aria-label="Overlay FPS"></div>
                                </div>
                            </div>
                        </div>                                        <!-- Distance ESP Render Slider -->
                                        <div class="border rounded-lg p-4">
                                            <div class="flex items-center justify-between mb-3">
                                                <div>
                                                    <label class="text-sm font-medium">ESP Render Distance</label>
                                                    <p class="text-xs text-muted-foreground">Maximum distance for ESP rendering</p>
                                                </div>
                                                <span class="text-sm font-medium" id="espDistanceValue">50m</span>
                                            </div>
                                            <div class="slider-container" id="espDistanceSlider" data-min="10" data-max="100" data-value="50" data-step="1" data-precision="0" data-slider-key="espDistanceSlider" data-performance-setting="distance">
                                                <div class="slider-track">
                                                    <div class="slider-fill"></div>
                                                    <div class="slider-thumb" tabindex="0" role="slider" aria-valuemin="10" aria-valuemax="100" aria-valuenow="50" aria-label="ESP Render Distance"></div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <script>
        // Menu Settings App
        class MenuApp {
            constructor() {
                this.currentTab = 'visuals';
                this.settings = {
                    unlockAll: false,
                    recoilControl: 0,
                    fovEnhancement: 0,
                    speedBoost: false,
                    jumpHeight: 0,
                    enhancedGadgets: false,
                    aimAssistStrength: 0,
                    highPerformanceMode: false,
                    cpuPriority: 0
                };
                this.collapsedSections = {};
                this.autoSaveEnabled = true;
                this.loadingComplete = false;
                this.init();
            }
            
            init() {
                this.bindEvents();
                
                // CRITICAL: Set up DOM attributes BEFORE loading settings
                this.updateGadgetToggles();
                this.updateEnvironmentToggles();
                this.addMissingFeatureAttributes();
                
                this.loadSettings(); // This will set the correct currentTab
                this.loadCollapsedStates();
                this.initPerformanceFeatures();
                this.initTabSlider();
                this.initCollapsibleSections();
                this.initMasterToggles();
                
                // Ensure correct tab is active after loading settings
                this.ensureCorrectTabActive();
                
                // Update tab slider position after DOM is ready
                setTimeout(() => {
                    this.updateTabSlider();
                }, 100);
                
                // Mark loading as complete - with extra delay for auto-save to settle
                setTimeout(() => {
                    this.loadingComplete = true;
                    this.autoSaveEnabled = true; // Ensure auto-save is enabled after loading
                    // Dispatch custom event that settings have loaded
                    window.dispatchEvent(new CustomEvent('menuAppLoaded'));
                    
                    // Force one immediate save to ensure everything is captured
                    this.saveSettings();
                    
                    // Add debug method to window for testing
                    window.debugESP = {
                        testSave: () => this.saveSettings(),
                        testLoad: () => this.loadSettings(),
                        clearStorage: () => localStorage.removeItem('solaraEspConfig'),
                        showConfig: () => console.log(JSON.parse(localStorage.getItem('solaraEspConfig') || '{}')),
                        testSliderSave: () => {
                            console.log('=== TESTING SLIDER SAVE PROCESS ===');
                            
                            // Get both performance sliders
                            const fpsSlider = document.getElementById('overlayFpsSlider');
                            const distanceSlider = document.getElementById('espDistanceSlider');
                            
                            console.log('1. 🔍 Finding sliders:');
                            console.log('   FPS Slider:', fpsSlider ? '✅ FOUND' : '❌ NOT FOUND', fpsSlider);
                            console.log('   Distance Slider:', distanceSlider ? '✅ FOUND' : '❌ NOT FOUND', distanceSlider);
                            
                            if (!fpsSlider || !distanceSlider) {
                                console.log('❌ Cannot proceed - sliders not found');
                                return;
                            }
                            
                            console.log('2. 📋 Current slider states:');
                            console.log('   FPS Slider value:', fpsSlider.getAttribute('data-value'));
                            console.log('   FPS Slider config:', fpsSlider._sliderConfig);
                            console.log('   FPS Slider state:', fpsSlider._sliderState);
                            console.log('   Distance Slider value:', distanceSlider.getAttribute('data-value'));
                            console.log('   Distance Slider config:', distanceSlider._sliderConfig);
                            console.log('   Distance Slider state:', distanceSlider._sliderState);
                            
                            console.log('3. 🎛️ Testing slider update:');
                            console.log('   Setting FPS slider to 90...');
                            this.setSliderValue(fpsSlider, 90);
                            console.log('   FPS slider data-value after update:', fpsSlider.getAttribute('data-value'));
                            console.log('   FPS display value:', document.getElementById('overlayFpsValue')?.textContent);
                            
                            console.log('   Setting Distance slider to 75...');
                            this.setSliderValue(distanceSlider, 75);
                            console.log('   Distance slider data-value after update:', distanceSlider.getAttribute('data-value'));
                            console.log('   Distance display value:', document.getElementById('espDistanceValue')?.textContent);
                            
                            console.log('4. 💾 Testing manual save:');
                            console.log('   App flags - autoSaveEnabled:', this.autoSaveEnabled, ', loadingComplete:', this.loadingComplete);
                            
                            // Clear storage first
                            localStorage.removeItem('solaraEspConfig');
                            console.log('   Cleared storage');
                            
                            // Force save
                            console.log('   Calling saveSettings(true)...');
                            this.saveSettings(true);
                            
                            // Check what was saved
                            const savedConfig = localStorage.getItem('solaraEspConfig');
                            console.log('   Raw saved config:', savedConfig);
                            
                            if (savedConfig) {
                                const config = JSON.parse(savedConfig);
                                console.log('   Parsed config:', config);
                                console.log('   Slider values in config:', config.ui?.sliders);
                                console.log('   FPS slider saved as:', config.ui?.sliders?.overlayFpsSlider);
                                console.log('   Distance slider saved as:', config.ui?.sliders?.espDistanceSlider);
                            } else {
                                console.log('   ❌ Nothing was saved to localStorage!');
                            }
                            
                            console.log('5. 🔄 Testing load:');
                            // Reset sliders first
                            this.setSliderValue(fpsSlider, 60);
                            this.setSliderValue(distanceSlider, 50);
                            console.log('   Reset sliders to defaults');
                            console.log('   FPS before load:', document.getElementById('overlayFpsValue')?.textContent);
                            console.log('   Distance before load:', document.getElementById('espDistanceValue')?.textContent);
                            
                            // Load settings
                            this.loadSettings();
                            console.log('   Called loadSettings()');
                            console.log('   FPS after load:', document.getElementById('overlayFpsValue')?.textContent);
                            console.log('   Distance after load:', document.getElementById('espDistanceValue')?.textContent);
                            
                            console.log('6. 📊 FINAL RESULTS:');
                            const finalFps = document.getElementById('overlayFpsValue')?.textContent;
                            const finalDistance = document.getElementById('espDistanceValue')?.textContent;
                            console.log(`   FPS Save/Load: ${finalFps === '90 FPS' ? '✅ SUCCESS' : '❌ FAILED'} (${finalFps})`);
                            console.log(`   Distance Save/Load: ${finalDistance === '75m' ? '✅ SUCCESS' : '❌ FAILED'} (${finalDistance})`);
                        },
                        testProblematicFeatures: () => {
                            console.log('=== TESTING PROBLEMATIC FEATURES ===');
                            const problematicIds = ['icons-toggle', 'names-toggle', 'skeleton-esp-toggle', 'skeleton-toggle-2', 'trap-esp-toggle', 'camera-esp-toggle', 'traps-duplicate-toggle', 'cameras-duplicate-toggle'];
                            const problematicColors = ['skeleton', 'traps', 'cameras'];
                            
                            console.log('Toggle Elements:');
                            problematicIds.forEach(id => {
                                const element = document.getElementById(id);
                                console.log(`${id}:`, element ? 'FOUND' : 'NOT FOUND', element);
                            });
                            
                            console.log('Color Circles:');
                            problematicColors.forEach(feature => {
                                const circles = document.querySelectorAll(`[data-feature="${feature}"].color-circle`);
                                console.log(`${feature}:`, circles.length, 'circles found', circles);
                            });
                            
                            console.log('Current Config:');
                            const config = JSON.parse(localStorage.getItem('solaraEspConfig') || '{}');
                            if (config.ui) {
                                console.log('Saved toggles:', Object.keys(config.ui.toggles || {}));
                                console.log('Saved colors:', Object.keys(config.ui.colors || {}));
                            }
                        },
                        deepAnalyzeIconsNames: () => {
                            console.log('=== DEEP ICONS/NAMES ANALYSIS ===');
                            
                            // Find Icons and Names toggles
                            const iconsToggle = document.getElementById('icons-toggle');
                            const namesToggle = document.getElementById('names-toggle');
                            
                            console.log('Icons Toggle Element:', iconsToggle);
                            if (iconsToggle) {
                                console.log('  - ID:', iconsToggle.id);
                                console.log('  - data-feature:', iconsToggle.getAttribute('data-feature'));
                                console.log('  - data-group:', iconsToggle.getAttribute('data-group'));
                                console.log('  - Classes:', iconsToggle.className);
                                console.log('  - Current state:', iconsToggle.getAttribute('data-state'));
                                console.log('  - Is child toggle:', iconsToggle.classList.contains('child-toggle'));
                            }
                            
                            console.log('Names Toggle Element:', namesToggle);
                            if (namesToggle) {
                                console.log('  - ID:', namesToggle.id);
                                console.log('  - data-feature:', namesToggle.getAttribute('data-feature'));
                                console.log('  - data-group:', namesToggle.getAttribute('data-group'));
                                console.log('  - Classes:', namesToggle.className);
                                console.log('  - Current state:', namesToggle.getAttribute('data-state'));
                                console.log('  - Is child toggle:', namesToggle.classList.contains('child-toggle'));
                            }
                            
                            // Find their master toggle
                            const gadgetMaster = document.querySelector('[data-group="gadget-esp"].master-toggle');
                            console.log('Gadget ESP Master Toggle:', gadgetMaster);
                            if (gadgetMaster) {
                                console.log('  - ID:', gadgetMaster.id);
                                console.log('  - data-group:', gadgetMaster.getAttribute('data-group'));
                                console.log('  - Classes:', gadgetMaster.className);
                                console.log('  - Current state:', gadgetMaster.getAttribute('data-state'));
                            }
                            
                            // Test save operation for these specific toggles
                            console.log('--- SIMULATING SAVE FOR ICONS/NAMES ---');
                            const allToggles = document.querySelectorAll('.toggle-switch');
                            allToggles.forEach((toggle, index) => {
                                if (toggle.id === 'icons-toggle' || toggle.id === 'names-toggle') {
                                    const state = toggle.getAttribute('data-state') === 'checked';
                                    
                                    console.log(`Toggle ${toggle.id}:`);
                                    console.log('  - Index:', index);
                                    console.log('  - State:', state);
                                    console.log('  - Would save as key:', toggle.id);
                                    console.log('  - Full element:', toggle);
                                }
                            });
                        },
                        testIconsNamesStepByStep: () => {
                            console.log('=== STEP BY STEP ICONS/NAMES TEST ===');
                            
                            // Step 0: Check loading flags
                            console.log('0. 🚦 Checking loading flags:');
                            console.log('   autoSaveEnabled:', this.autoSaveEnabled);
                            console.log('   loadingComplete:', this.loadingComplete);
                            
                            // Step 1: Clear everything
                            localStorage.removeItem('solaraEspConfig');
                            console.log('1. ✅ Cleared localStorage');
                            
                            // Step 2: Find all relevant elements
                            const iconsToggle = document.getElementById('icons-toggle');
                            const namesToggle = document.getElementById('names-toggle');
                            const masterToggle = document.querySelector('[data-group="gadget-esp"].master-toggle');
                            const container = document.querySelector('.gadget-esp-children');
                            
                            console.log('2. 🔍 Found elements:');
                            console.log('   Icons toggle:', iconsToggle ? '✅ FOUND' : '❌ NOT FOUND', iconsToggle);
                            console.log('   Names toggle:', namesToggle ? '✅ FOUND' : '❌ NOT FOUND', namesToggle);
                            console.log('   Master toggle:', masterToggle ? '✅ FOUND' : '❌ NOT FOUND', masterToggle);
                            console.log('   Container:', container ? '✅ FOUND' : '❌ NOT FOUND', container);
                            
                            if (!iconsToggle || !namesToggle || !masterToggle) {
                                console.log('❌ Missing critical elements, cannot continue');
                                return;
                            }
                            
                            // Step 3: Check initial attributes
                            console.log('3. 📋 Initial attributes:');
                            console.log('   Icons - data-group:', iconsToggle.getAttribute('data-group'));
                            console.log('   Icons - child-toggle class:', iconsToggle.classList.contains('child-toggle'));
                            console.log('   Icons - data-state:', iconsToggle.getAttribute('data-state'));
                            console.log('   Names - data-group:', namesToggle.getAttribute('data-group'));
                            console.log('   Names - child-toggle class:', namesToggle.classList.contains('child-toggle'));
                            console.log('   Names - data-state:', namesToggle.getAttribute('data-state'));
                            console.log('   Master - data-state:', masterToggle.getAttribute('data-state'));
                            console.log('   Container opacity:', container.style.opacity);
                            console.log('   Container pointer-events:', container.style.pointerEvents);
                            
                            // Step 4: Try to enable master manually
                            console.log('4. 🔧 Manually enabling master toggle');
                            this.setToggleState(masterToggle, 'checked');
                            container.style.opacity = '1';
                            container.style.pointerEvents = 'auto';
                            console.log('   Master state after enable:', masterToggle.getAttribute('data-state'));
                            
                            // Step 5: Try to enable icons manually
                            console.log('5. 🔧 Manually enabling icons toggle');
                            this.setToggleState(iconsToggle, 'checked');
                            console.log('   Icons state after enable:', iconsToggle.getAttribute('data-state'));
                            
                            // Step 6: Try to enable names manually
                            console.log('6. 🔧 Manually enabling names toggle');
                            this.setToggleState(namesToggle, 'checked');
                            console.log('   Names state after enable:', namesToggle.getAttribute('data-state'));
                            
                            // Step 7: Manually trigger save
                            console.log('7. 💾 Manually triggering save');
                            this.saveSettings();
                            
                            // Step 8: Check what was actually saved
                            console.log('8. 🔍 Checking saved data');
                            const config = JSON.parse(localStorage.getItem('solaraEspConfig') || '{}');
                            console.log('   Full config:', config);
                            
                            if (config.ui && config.ui.toggles) {
                                console.log('   All saved toggle keys:', Object.keys(config.ui.toggles));
                                console.log('   Icons in config:', config.ui.toggles['icons-toggle']);
                                console.log('   Names in config:', config.ui.toggles['names-toggle']);
                                console.log('   Master in config:', config.ui.toggles['gadget-esp-master']);
                            } else {
                                console.log('   ❌ No toggles saved at all!');
                            }
                            
                            // Step 9: Reset all toggles to unchecked
                            console.log('9. 🔄 Resetting all toggles to test restore');
                            this.setToggleState(masterToggle, 'unchecked');
                            this.setToggleState(iconsToggle, 'unchecked');
                            this.setToggleState(namesToggle, 'unchecked');
                            container.style.opacity = '0.5';
                            container.style.pointerEvents = 'none';
                            
                            console.log('   Master after reset:', masterToggle.getAttribute('data-state'));
                            console.log('   Icons after reset:', iconsToggle.getAttribute('data-state'));
                            console.log('   Names after reset:', namesToggle.getAttribute('data-state'));
                            
                            // Step 10: Try to restore
                            console.log('10. 📥 Attempting to restore from saved config');
                            this.loadSettings();
                            
                            // Step 11: Check final states
                            console.log('11. 🎯 Final states after restore:');
                            console.log('   Master final state:', masterToggle.getAttribute('data-state'));
                            console.log('   Icons final state:', iconsToggle.getAttribute('data-state'));
                            console.log('   Names final state:', namesToggle.getAttribute('data-state'));
                            console.log('   Container final opacity:', container.style.opacity);
                            console.log('   Container final pointer-events:', container.style.pointerEvents);
                            
                            // Step 12: Summary
                            const masterWorked = masterToggle.getAttribute('data-state') === 'checked';
                            const iconsWorked = iconsToggle.getAttribute('data-state') === 'checked';
                            const namesWorked = namesToggle.getAttribute('data-state') === 'checked';
                            
                            console.log('12. 📊 FINAL RESULTS:');
                            console.log(`   Master toggle: ${masterWorked ? '✅ WORKS' : '❌ FAILED'}`);
                            console.log(`   Icons toggle: ${iconsWorked ? '✅ WORKS' : '❌ FAILED'}`);
                            console.log(`   Names toggle: ${namesWorked ? '✅ WORKS' : '❌ FAILED'}`);
                            
                            if (!iconsWorked || !namesWorked) {
                                console.log('🐛 DEBUGGING INFO:');
                                console.log('   Issue likely in save/restore logic');
                                console.log('   Check if toggles are being found during restore');
                                console.log('   Check if master-child dependency logic is working');
                            }
                        },
                        forceSaveIgnoreFlags: () => {
                            console.log('=== FORCE SAVE (IGNORING FLAGS) ===');
                            const originalAutoSave = this.autoSaveEnabled;
                            const originalLoadingComplete = this.loadingComplete;
                            
                            // Temporarily enable flags
                            this.autoSaveEnabled = true;
                            this.loadingComplete = true;
                            
                            console.log('Temporarily enabled flags and calling saveSettings()');
                            this.saveSettings();
                            
                            // Restore original flags
                            this.autoSaveEnabled = originalAutoSave;
                            this.loadingComplete = originalLoadingComplete;
                            
                            console.log('Config after force save:', JSON.parse(localStorage.getItem('solaraEspConfig') || '{}'));
                        },
                        testBasicSave: () => {
                            console.log('=== BASIC SAVE TEST ===');
                            
                            try {
                                // Test basic localStorage functionality
                                localStorage.setItem('test', 'works');
                                const testResult = localStorage.getItem('test');
                                console.log('Basic localStorage test:', testResult === 'works' ? '✅ WORKS' : '❌ FAILED');
                                localStorage.removeItem('test');
                                
                                // Create minimal config manually
                                const iconsToggle = document.getElementById('icons-toggle');
                                const namesToggle = document.getElementById('names-toggle');
                                
                                if (iconsToggle && namesToggle) {
                                    // Set both to checked
                                    iconsToggle.setAttribute('data-state', 'checked');
                                    namesToggle.setAttribute('data-state', 'checked');
                                    
                                    const minimalConfig = {
                                        version: '1.0',
                                        timestamp: Date.now(),
                                        ui: {
                                            toggles: {
                                                'icons-toggle': {
                                                    state: true,
                                                    id: 'icons-toggle'
                                                },
                                                'names-toggle': {
                                                    state: true,
                                                    id: 'names-toggle'
                                                }
                                            }
                                        }
                                    };
                                    
                                    console.log('Saving minimal config:', minimalConfig);
                                    localStorage.setItem('solaraEspConfig', JSON.stringify(minimalConfig));
                                    
                                    const saved = JSON.parse(localStorage.getItem('solaraEspConfig'));
                                    console.log('Saved config retrieved:', saved);
                                    
                                    // Test basic restore
                                    iconsToggle.setAttribute('data-state', 'unchecked');
                                    namesToggle.setAttribute('data-state', 'unchecked');
                                    
                                    console.log('Reset toggles to unchecked');
                                    console.log('Icons state:', iconsToggle.getAttribute('data-state'));
                                    console.log('Names state:', namesToggle.getAttribute('data-state'));
                                    
                                    // Restore manually
                                    if (saved.ui && saved.ui.toggles) {
                                        if (saved.ui.toggles['icons-toggle'] && saved.ui.toggles['icons-toggle'].state) {
                                            iconsToggle.setAttribute('data-state', 'checked');
                                            console.log('Manually restored icons to checked');
                                        }
                                        if (saved.ui.toggles['names-toggle'] && saved.ui.toggles['names-toggle'].state) {
                                            namesToggle.setAttribute('data-state', 'checked');
                                            console.log('Manually restored names to checked');
                                        }
                                    }
                                    
                                    console.log('Final states:');
                                    console.log('Icons:', iconsToggle.getAttribute('data-state'));
                                    console.log('Names:', namesToggle.getAttribute('data-state'));
                                    
                                } else {
                                    console.log('❌ Could not find icons or names toggles');
                                }
                                
                            } catch (error) {
                                console.log('❌ Error in basic save test:', error);
                            }
                        }
                    };
                    console.log('Debug methods available: window.debugESP.testSave(), testLoad(), clearStorage(), showConfig(), testProblematicFeatures(), deepAnalyzeIconsNames(), testIconsNamesStepByStep(), forceSaveIgnoreFlags(), testBasicSave()');
                }, 300); // Increased delay to ensure all DOM manipulation is complete
            }
            
            bindEvents() {
                // Tab switching
                document.querySelectorAll('.settings-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        const tabName = e.currentTarget.getAttribute('data-tab');
                        this.switchTab(tabName);
                    });
                });
                
                // Toggle switches - using event delegation for better reliability
                document.addEventListener('click', (e) => {
                    const toggle = e.target.closest('.toggle-switch');
                    if (toggle) {
                        // Debug child toggle clicks
                        if (['icons-toggle', 'names-toggle'].includes(toggle.id)) {
                            console.log(`=== CLICK EVENT for ${toggle.id} ===`);
                            console.log('Click target:', e.target);
                            console.log('Toggle element:', toggle);
                            console.log('Event path:', e.composedPath());
                        }
                        
                        // Handle master toggles through their specific handler
                        if (toggle.classList.contains('master-toggle')) {
                            // Master toggles handled in initMasterToggles
                            if (['icons-toggle', 'names-toggle'].includes(toggle.id)) {
                                console.log('This is a master toggle, handled separately');
                            }
                            return;
                        }
                        
                        // Check if child toggle is disabled by master
                        if (toggle.classList.contains('child-toggle')) {
                            const group = toggle.getAttribute('data-group');
                            if (group) {
                                const container = document.querySelector(`.${group}-children`);
                                const masterToggle = document.querySelector(`[data-group="${group}"].master-toggle`);
                                
                                if (container && container.style.pointerEvents === 'none' && masterToggle) {
                                    if (['icons-toggle', 'names-toggle'].includes(toggle.id)) {
                                        console.log('Auto-enabling master toggle first for disabled child');
                                    }
                                    
                                    // Auto-enable the master toggle first
                                    this.setToggleState(masterToggle, 'checked');
                                    container.style.opacity = '1';
                                    container.style.pointerEvents = 'auto';
                                    
                                    // Show notification about auto-enabling master
                                    const masterName = group.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase());
                                    this.showToast(`${masterName} auto-enabled`, 'info');
                                    
                                    // Save the master toggle state
                                    this.saveSettings();
                                    
                                    // Now proceed with the child toggle
                                }
                            }
                        }
                        
                        // Handle regular toggles
                        this.toggleSwitch(toggle);                        // Synchronize duplicate toggles with same data-feature
                        const feature = toggle.getAttribute('data-feature');
                        if (feature) {
                            const duplicateToggles = document.querySelectorAll(`[data-feature="${feature}"].toggle-switch`);
                            duplicateToggles.forEach(dupToggle => {
                                if (dupToggle !== toggle) {
                                    this.setToggleState(dupToggle, toggle.getAttribute('data-state'));
                                }
                            });
                        }
                    }
                });
                
                // Color pickers
                this.initColorPickers();
                
                // Sliders
                document.querySelectorAll('.slider-container').forEach(slider => {
                    this.initSlider(slider);
                });
            }
            
            switchTab(tabName) {
                if (this.currentTab === tabName) return;
                
                // Update tab buttons
                document.querySelectorAll('.settings-tab').forEach(tab => {
                    const isActive = tab.getAttribute('data-tab') === tabName;
                    tab.classList.toggle('active', isActive);
                });
                
                // Update tab slider position
                this.updateTabSlider();
                
                // Update content panels - map new tabs to existing content
                document.querySelectorAll('.settings-content').forEach(content => {
                    content.style.display = 'none';
                });
                
                let targetContentId;
                switch(tabName) {
                    case 'visuals':
                        targetContentId = 'visuals-settings';
                        break;
                    case 'performance':
                        targetContentId = 'performance-settings';
                        break;
                    default:
                        targetContentId = 'visuals-settings';
                        break;
                }
                
                const targetContent = document.getElementById(targetContentId);
                if (targetContent) {
                    targetContent.style.display = 'block';
                }
                
                this.currentTab = tabName;
                this.saveState(); // Auto-save tab change
            }
            
            ensureCorrectTabActive() {
                // Make sure the DOM reflects the current tab state
                document.querySelectorAll('.settings-tab').forEach(tab => {
                    const isActive = tab.getAttribute('data-tab') === this.currentTab;
                    tab.classList.toggle('active', isActive);
                });
                
                // Show the correct content panel
                document.querySelectorAll('.settings-content').forEach(content => {
                    content.style.display = 'none';
                });
                
                let targetContentId;
                switch(this.currentTab) {
                    case 'visuals':
                        targetContentId = 'visuals-settings';
                        break;
                    case 'performance':
                        targetContentId = 'performance-settings';
                        break;
                    default:
                        targetContentId = 'visuals-settings';
                        break;
                }
                
                const targetContent = document.getElementById(targetContentId);
                if (targetContent) {
                    targetContent.style.display = 'block';
                }
            }
            
            toggleSwitch(toggleElement) {
                const isChecked = toggleElement.getAttribute('data-state') === 'checked';
                const newState = isChecked ? 'unchecked' : 'checked';
                const toggleId = toggleElement.id;
                
                // Debug specific toggles
                if (['icons-toggle', 'names-toggle'].includes(toggleId)) {
                    console.log(`=== TOGGLE CLICK DEBUG for ${toggleId} ===`);
                    console.log('Current state:', isChecked);
                    console.log('New state:', newState);
                    console.log('Is child toggle:', toggleElement.classList.contains('child-toggle'));
                    console.log('Data group:', toggleElement.getAttribute('data-group'));
                    
                    // Check master toggle state
                    const group = toggleElement.getAttribute('data-group');
                    if (group) {
                        const masterToggle = document.querySelector(`[data-group="${group}"].master-toggle`);
                        console.log('Master toggle:', masterToggle);
                        console.log('Master state:', masterToggle ? masterToggle.getAttribute('data-state') : 'NO MASTER');
                        
                        // Check container state
                        const container = document.querySelector(`.${group}-children`);
                        console.log('Container:', container);
                        console.log('Container opacity:', container ? container.style.opacity : 'NO CONTAINER');
                        console.log('Container pointer events:', container ? container.style.pointerEvents : 'NO CONTAINER');
                    }
                }
                
                this.setToggleState(toggleElement, newState);
                
                // Handle health bar position visibility
                if (toggleElement.id === 'health-bar-toggle') {
                    const divider = document.querySelector('.health-bar-divider');
                    const position = document.querySelector('.health-bar-position');
                    if (newState === 'checked') {
                        divider.style.display = 'block';
                        position.style.display = 'block';
                    } else {
                        divider.style.display = 'none';
                        position.style.display = 'none';
                    }
                }
                
                // Get a more descriptive name for the notification
                let featureName = 'Setting';
                const id = toggleElement.id;
                const feature = toggleElement.getAttribute('data-feature');
                const group = toggleElement.getAttribute('data-group');
                const parentLabel = toggleElement.closest('.flex')?.querySelector('label')?.textContent?.trim();
                
                if (parentLabel) {
                    featureName = parentLabel;
                } else if (feature) {
                    featureName = feature.charAt(0).toUpperCase() + feature.slice(1);
                } else if (id) {
                    featureName = id.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                } else if (group) {
                    featureName = group.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                }
                
                this.saveSettings();
                this.saveState(); // Auto-save all states
                this.showToast(`${featureName} ${newState === 'checked' ? 'enabled' : 'disabled'}`, 'success');
            }
            
            setToggleState(toggleElement, state) {
                toggleElement.setAttribute('data-state', state);
                toggleElement.setAttribute('aria-checked', state === 'checked');
                
                const thumb = toggleElement.querySelector('.toggle-thumb');
                thumb.setAttribute('data-state', state);
                
                if (state === 'checked') {
                    toggleElement.classList.add('bg-primary');
                    toggleElement.classList.remove('bg-input');
                    thumb.style.transform = 'translateX(16px)';
                } else {
                    toggleElement.classList.remove('bg-primary');
                    toggleElement.classList.add('bg-input');
                    thumb.style.transform = 'translateX(0)';
                }
            }
            
            initSlider(sliderContainer) {
                const thumb = sliderContainer.querySelector('.slider-thumb');
                const track = sliderContainer.querySelector('.slider-track');
                const fill = sliderContainer.querySelector('.slider-fill');
                
                if (!thumb || !track || !fill) {
                    console.warn('Slider initialization failed: Missing required elements');
                    return;
                }
                
                // Create unique identifier for this slider instance
                const sliderId = sliderContainer.id || `slider-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                if (!sliderContainer.id) {
                    sliderContainer.id = sliderId;
                }
                
                // Enhanced value display detection with better fallbacks - UNIQUE per slider
                let valueDisplay = null;
                
                // Use slider ID to find the correct corresponding value display - CONSISTENT with setSliderValue
                if (sliderId === 'overlayFpsSlider') {
                    valueDisplay = document.querySelector('#overlayFpsValue');
                } else if (sliderId === 'espDistanceSlider') {
                    valueDisplay = document.querySelector('#espDistanceValue');
                } else {
                    // Fallback to closest value display for other sliders
                    valueDisplay = sliderContainer.closest('.border').querySelector('.slider-value') ||
                                   sliderContainer.closest('.border').querySelector('[id$="Value"]');
                }
                
                // Create value display if it doesn't exist
                if (!valueDisplay) {
                    const parentElement = sliderContainer.parentElement.parentElement;
                    valueDisplay = document.createElement('span');
                    valueDisplay.className = 'slider-value text-sm font-medium';
                    valueDisplay.id = `${sliderId}-value`;
                    const headerElement = parentElement.querySelector('.feature-header') || 
                                        parentElement.querySelector('.flex.items-center.justify-between') || 
                                        parentElement;
                    headerElement.appendChild(valueDisplay);
                }
                
                // Enhanced slider configuration - ISOLATED per slider
                const config = {
                    sliderId: sliderId,
                    minValue: parseInt(sliderContainer.getAttribute('data-min')) || 0,
                    maxValue: parseInt(sliderContainer.getAttribute('data-max')) || 100,
                    step: parseInt(sliderContainer.getAttribute('data-step')) || 1,
                    precision: parseInt(sliderContainer.getAttribute('data-precision')) || 0
                };
                
                config.range = config.maxValue - config.minValue;
                
                // Determine initial value with enhanced defaults - UNIQUE per slider
                let initialValue = parseInt(sliderContainer.getAttribute('data-value'));
                if (isNaN(initialValue)) {
                    if (sliderId === 'overlayFpsSlider' || valueDisplay?.id === 'overlayFpsValue') {
                        initialValue = 60;
                    } else if (sliderId === 'espDistanceSlider' || valueDisplay?.id === 'espDistanceValue') {
                        initialValue = 50;
                    } else {
                        initialValue = Math.round((config.minValue + config.maxValue) / 2);
                    }
                }
                
                // Enhanced value formatting with better precision - SPECIFIC per slider
                const formatDisplayValue = (val) => {
                    const roundedVal = config.precision > 0 ? 
                        parseFloat(val.toFixed(config.precision)) : 
                        Math.round(val);
                        
                    // Use ONLY slider ID for formatting to avoid cross-contamination
                    if (sliderId === 'overlayFpsSlider') {
                        return `${roundedVal} FPS`;
                    } else if (sliderId === 'espDistanceSlider') {
                        return `${roundedVal}m`;
                    } else {
                        return `${roundedVal}%`;
                    }
                };
                
                // State management - ISOLATED per slider instance
                let sliderState = {
                    isDragging: false,
                    isKeyboardFocused: false,
                    lastSaveTime: 0,
                    saveTimeout: null,
                    currentValue: initialValue
                };
                
                // Enhanced throttling for performance - UNIQUE per slider
                const throttle = (func, limit) => {
                    let inThrottle;
                    return function() {
                        const args = arguments;
                        const context = this;
                        if (!inThrottle) {
                            func.apply(context, args);
                            inThrottle = true;
                            setTimeout(() => inThrottle = false, limit);
                        }
                    }
                };
                
                // Debounced auto-save function - SPECIFIC to this slider
                const self = this; // Capture the MenuApp instance
                const debouncedSave = () => {
                    if (sliderState.saveTimeout) clearTimeout(sliderState.saveTimeout);
                    sliderState.saveTimeout = setTimeout(() => {
                        console.log(`🔍 Auto-save check for slider: ${config.sliderId}`);
                        console.log(`   - Is performance slider?`, ['overlayFpsSlider', 'espDistanceSlider'].includes(config.sliderId));
                        console.log(`   - Auto-save enabled?`, self.autoSaveEnabled);
                        console.log(`   - Loading complete?`, self.loadingComplete);
                        console.log(`   - Current value:`, sliderState.currentValue);
                        
                        if (['overlayFpsSlider', 'espDistanceSlider'].includes(config.sliderId)) {
                            console.log(`💾 Auto-saving slider ${config.sliderId} with value: ${sliderState.currentValue}`);
                            
                            // Force save for performance sliders using override parameter
                            // Use captured self reference to maintain context
                            self.saveSettings(true); // Force override enabled
                            
                            sliderState.lastSaveTime = Date.now();
                            console.log(`✅ Performance slider ${config.sliderId} saved successfully`);
                        } else {
                            console.log(`⚠️ Slider ${config.sliderId} not in performance slider list, skipping auto-save`);
                        }
                    }, 300); // 300ms debounce
                };
                
                // Enhanced slider update function - COMPLETELY ISOLATED per slider
                const updateSlider = throttle((clientX, skipAnimation = false) => {
                    const rect = track.getBoundingClientRect();
                    const percentage = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
                    const rawValue = config.minValue + (percentage / 100) * config.range;
                    
                    // Apply step and precision constraints
                    const steppedValue = Math.round(rawValue / config.step) * config.step;
                    const clampedValue = Math.max(config.minValue, Math.min(config.maxValue, steppedValue));
                    const finalPercentage = ((clampedValue - config.minValue) / config.range) * 100;
                    
                    // Update internal state FIRST
                    sliderState.currentValue = clampedValue;
                    
                    // Enhanced visual updates with smooth transitions - TARGET ONLY THIS SLIDER
                    if (skipAnimation) {
                        thumb.style.transition = 'none';
                        fill.style.transition = 'none';
                    } else {
                        thumb.style.transition = 'left 0.15s cubic-bezier(0.4, 0, 0.2, 1)';
                        fill.style.transition = 'width 0.15s cubic-bezier(0.4, 0, 0.2, 1)';
                    }
                    
                    // Update ONLY this slider's elements
                    thumb.style.left = `${finalPercentage}%`;
                    fill.style.width = `${finalPercentage}%`;
                    
                    // Enhanced value display updates - TARGET ONLY THIS SLIDER'S DISPLAY
                    if (valueDisplay) {
                        const newDisplayValue = formatDisplayValue(clampedValue);
                        valueDisplay.textContent = newDisplayValue;
                        
                        // Add subtle animation to THIS value display only
                        valueDisplay.style.transition = 'transform 0.1s ease';
                        valueDisplay.style.transform = 'scale(1.05)';
                        setTimeout(() => {
                            if (valueDisplay) { // Safety check
                                valueDisplay.style.transform = 'scale(1)';
                            }
                        }, 100);
                    }
                    
                    // Enhanced ARIA updates - UPDATE ONLY THIS SLIDER
                    thumb.setAttribute('aria-valuenow', clampedValue);
                    thumb.setAttribute('aria-valuetext', formatDisplayValue(clampedValue));
                    sliderContainer.setAttribute('data-value', clampedValue);
                    
                    // Reset transitions after animation
                    if (skipAnimation) {
                        setTimeout(() => {
                            thumb.style.transition = '';
                            fill.style.transition = '';
                        }, 16);
                    }
                    
                    // Debug logging for verification
                    console.log(`🎛️ Slider ${config.sliderId} updated to: ${clampedValue} (${newDisplayValue})`);
                    
                    // Trigger auto-save
                    console.log(`🔄 Triggering debouncedSave for ${config.sliderId}...`);
                    debouncedSave();
                    
                    return clampedValue;
                }, 16); // ~60fps throttling
                
                // Enhanced visual feedback methods - SPECIFIC to this slider
                const addDragEffect = () => {
                    thumb.style.transform = 'translateY(-50%) scale(1.1)';
                    thumb.style.boxShadow = `
                        0 0 0 2px hsl(var(--primary) / 0.3),
                        0 4px 16px rgba(0, 0, 0, 0.25),
                        0 2px 8px rgba(0, 0, 0, 0.2),
                        inset 0 2px 4px rgba(0, 0, 0, 0.4),
                        inset 0 -1px 2px rgba(255, 255, 255, 0.05)`;
                    track.style.boxShadow = `
                        inset 0 1px 2px rgba(0, 0, 0, 0.4),
                        inset 0 -1px 1px rgba(255, 255, 255, 0.03),
                        0 0 0 2px hsl(var(--primary) / 0.2)`;
                };
                
                const removeDragEffect = () => {
                    thumb.style.transform = 'translateY(-50%)';
                    thumb.style.boxShadow = '';
                    track.style.boxShadow = '';
                };
                
                const addFocusEffect = () => {
                    thumb.style.outline = '2px solid hsl(var(--primary))';
                    thumb.style.outlineOffset = '2px';
                };
                
                const removeFocusEffect = () => {
                    thumb.style.outline = '';
                    thumb.style.outlineOffset = '';
                };
                
                // Enhanced mouse event handlers - ISOLATED event handling
                thumb.addEventListener('mousedown', (e) => {
                    sliderState.isDragging = true;
                    addDragEffect();
                    thumb.focus();
                    
                    const onMouseMove = (e) => {
                        if (sliderState.isDragging) {
                            updateSlider.call(this, e.clientX);
                            e.preventDefault();
                        }
                    };
                    
                    const onMouseUp = () => {
                        sliderState.isDragging = false;
                        removeDragEffect();
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    };
                    
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                    e.preventDefault();
                });
                
                // Enhanced touch event handlers - ISOLATED touch handling
                thumb.addEventListener('touchstart', (e) => {
                    sliderState.isDragging = true;
                    addDragEffect();
                    
                    const onTouchMove = (e) => {
                        if (sliderState.isDragging && e.touches.length > 0) {
                            const touch = e.touches[0];
                            updateSlider.call(this, touch.clientX);
                            e.preventDefault();
                        }
                    };
                    
                    const onTouchEnd = () => {
                        sliderState.isDragging = false;
                        removeDragEffect();
                        document.removeEventListener('touchmove', onTouchMove);
                        document.removeEventListener('touchend', onTouchEnd);
                    };
                    
                    document.addEventListener('touchmove', onTouchMove, { passive: false });
                    document.addEventListener('touchend', onTouchEnd);
                    e.preventDefault();
                });
                
                // Enhanced track click - ISOLATED click handling
                track.addEventListener('click', (e) => {
                    if (e.target === track || e.target === fill) {
                        updateSlider.call(this, e.clientX);
                        
                        // Add click animation
                        const ripple = document.createElement('div');
                        ripple.style.cssText = `
                            position: absolute;
                            background: hsl(var(--primary) / 0.3);
                            border-radius: 50%;
                            width: 20px;
                            height: 20px;
                            left: ${e.offsetX - 10}px;
                            top: 50%;
                            transform: translateY(-50%) scale(0);
                            animation: ripple 0.6s ease-out;
                            pointer-events: none;
                        `;
                        
                        track.appendChild(ripple);
                        setTimeout(() => ripple.remove(), 600);
                    }
                });
                
                // Enhanced keyboard navigation - ISOLATED keyboard handling
                thumb.addEventListener('keydown', (e) => {
                    const currentValue = sliderState.currentValue;
                    let newValue = currentValue;
                    let stepSize = config.step;
                    
                    // Enhanced step sizes for different keys
                    if (e.shiftKey) stepSize *= 10; // Shift for larger steps
                    if (e.ctrlKey) stepSize *= 0.1;  // Ctrl for smaller steps
                    
                    switch(e.key) {
                        case 'ArrowLeft':
                        case 'ArrowDown':
                            newValue = Math.max(config.minValue, currentValue - stepSize);
                            break;
                        case 'ArrowRight':
                        case 'ArrowUp':
                            newValue = Math.min(config.maxValue, currentValue + stepSize);
                            break;
                        case 'Home':
                            newValue = config.minValue;
                            break;
                        case 'End':
                            newValue = config.maxValue;
                            break;
                        case 'PageDown':
                            newValue = Math.max(config.minValue, currentValue - (config.range * 0.1));
                            break;
                        case 'PageUp':
                            newValue = Math.min(config.maxValue, currentValue + (config.range * 0.1));
                            break;
                        default:
                            return;
                    }
                    
                    // Use setSliderValue to ensure proper isolation
                    self.setSliderValue(sliderContainer, newValue);
                    debouncedSave();
                    e.preventDefault();
                });
                
                // Enhanced focus and blur handlers - ISOLATED focus handling
                thumb.addEventListener('focus', () => {
                    sliderState.isKeyboardFocused = true;
                    addFocusEffect();
                });
                
                thumb.addEventListener('blur', () => {
                    sliderState.isKeyboardFocused = false;
                    removeFocusEffect();
                });
                
                // Initialize slider with enhanced setup - SET INITIAL STATE
                self.setSliderValue(sliderContainer, initialValue);
                
                // Enhanced ARIA setup - UNIQUE attributes
                thumb.setAttribute('role', 'slider');
                thumb.setAttribute('aria-valuemin', config.minValue);
                thumb.setAttribute('aria-valuemax', config.maxValue);
                thumb.setAttribute('aria-valuenow', initialValue);
                thumb.setAttribute('aria-valuetext', formatDisplayValue(initialValue));
                thumb.setAttribute('aria-label', `${config.sliderId} slider`);
                thumb.setAttribute('tabindex', '0');
                
                // Add slider identification for easier debugging - UNIQUE markers
                sliderContainer.setAttribute('data-slider-initialized', 'true');
                sliderContainer.setAttribute('data-slider-instance-id', config.sliderId);
                
                // Store the slider state on the container for debugging
                sliderContainer._sliderState = sliderState;
                sliderContainer._sliderConfig = config;
                
                console.log(`✅ Slider ${config.sliderId} initialized with value: ${initialValue}`);
                
                // Add CSS animation keyframes if not already present
                if (!document.querySelector('#slider-animations')) {
                    const style = document.createElement('style');
                    style.id = 'slider-animations';
                    style.textContent = `
                        @keyframes ripple {
                            to {
                                transform: translateY(-50%) scale(4);
                                opacity: 0;
                            }
                        }
                        
                        .slider-value {
                            transition: transform 0.1s ease;
                        }
                    `;
                    document.head.appendChild(style);
                }
            }
            
            saveSettings(forceOverride = false) {
                // Create comprehensive configuration object
                if (forceOverride || (this.autoSaveEnabled && this.loadingComplete)) {
                    console.log('=== SAVE SETTINGS DEBUG ===');
                    console.log('   - Force override:', forceOverride);
                    console.log('   - Auto-save enabled:', this.autoSaveEnabled);
                    console.log('   - Loading complete:', this.loadingComplete);
                    const config = {
                        version: '1.0',
                        timestamp: Date.now(),
                        currentTab: this.currentTab,
                        collapsedSections: { ...this.collapsedSections },
                        ui: {
                            toggles: {},
                            colors: {},
                            sliders: {},
                            selects: {}
                        }
                    };
                    
                    // Save ALL toggle states with enhanced identification methods
                    document.querySelectorAll('.toggle-switch').forEach((toggle, index) => {
                        const state = toggle.getAttribute('data-state') === 'checked';
                        
                        // Ultra-detailed debugging for Icons and Names
                        if (toggle.id === 'icons-toggle' || toggle.id === 'names-toggle') {
                            console.log(`\n=== SAVE DEBUG for ${toggle.id} ===`);
                            console.log('Element:', toggle);
                            console.log('Index:', index);
                            console.log('Current state attribute:', toggle.getAttribute('data-state'));
                            console.log('Computed state (checked):', state);
                            console.log('ID:', toggle.id);
                            console.log('data-feature:', toggle.getAttribute('data-feature'));
                            console.log('data-group:', toggle.getAttribute('data-group'));
                            console.log('Classes:', toggle.className);
                            console.log('Parent container:', toggle.closest('.gadget-esp-children'));
                        }
                        
                        // Enhanced identification with fallbacks - ALWAYS prioritize ID first
                        let key = null;
                        
                        // Priority 1: Use ID if available (this should be the primary method)
                        if (toggle.id) {
                            key = toggle.id;
                        }
                        // Priority 2: Generate from label text if no ID
                        else {
                            const parentLabel = toggle.closest('.flex')?.querySelector('label')?.textContent?.trim();
                            if (parentLabel) {
                                key = parentLabel.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '') + '-toggle';
                            }
                            // Priority 3: Use data-feature as last resort
                            else if (toggle.getAttribute('data-feature')) {
                                key = toggle.getAttribute('data-feature') + '-toggle';
                            }
                            // Priority 4: Use data-group for master toggles
                            else if (toggle.classList.contains('master-toggle') && toggle.getAttribute('data-group')) {
                                key = toggle.getAttribute('data-group') + '-master';
                            }
                            // Priority 5: Use data-setting if available
                            else if (toggle.getAttribute('data-setting')) {
                                key = toggle.getAttribute('data-setting');
                            }
                        }
                        
                        // Fallback: Use index-based key
                        if (!key) {
                            key = `toggle-index-${index}`;
                        }
                        
                        // Ultra-detailed debugging for Icons and Names key generation
                        if (toggle.id === 'icons-toggle' || toggle.id === 'names-toggle') {
                            console.log('Generated key:', key);
                            console.log('Will save as:', { state, key });
                        }
                        
                        // Store the toggle state with comprehensive metadata
                        config.ui.toggles[key] = {
                            state: state,
                            isMaster: toggle.classList.contains('master-toggle'),
                            isChild: toggle.classList.contains('child-toggle'),
                            group: toggle.getAttribute('data-group'),
                            feature: toggle.getAttribute('data-feature'),
                            setting: toggle.getAttribute('data-setting'),
                            id: toggle.id,
                            index: index,
                            labelText: toggle.closest('.flex')?.querySelector('label')?.textContent?.trim() || null
                        };
                        
                        if (['icons-toggle', 'names-toggle', 'skeleton-esp-toggle', 'skeleton-toggle-2', 'trap-esp-toggle', 'camera-esp-toggle', 'traps-duplicate-toggle', 'cameras-duplicate-toggle'].includes(key)) {
                            console.log(`Saving problematic toggle ${key}:`, config.ui.toggles[key]);
                        }
                    });
                    
                    // Save all color picker states
                    document.querySelectorAll('.color-circle[data-feature]').forEach(circle => {
                        const feature = circle.getAttribute('data-feature');
                        const color = circle.getAttribute('data-color') || circle.style.backgroundColor;
                        if (feature && color) {
                            config.ui.colors[feature] = color;
                            if (['skeleton', 'traps', 'cameras'].includes(feature)) {
                                console.log(`Saving problematic color for ${feature}:`, color);
                            }
                        }
                    });
                    
                    // Enhanced slider value saving with better identification
                    console.log('💾 Starting slider save process...');
                    document.querySelectorAll('.slider-container').forEach((container, index) => {
                        console.log(`   Checking slider ${index}:`, container);
                        const thumb = container.querySelector('.slider-thumb');
                        if (thumb) {
                            const value = container.getAttribute('data-value') || thumb.getAttribute('aria-valuenow') || '0';
                            console.log(`   - Raw value: "${value}"`);
                            
                            // Enhanced identification strategy for sliders
                            let key = container.id;
                            console.log(`   - ID: "${key}"`);
                            
                            // If no ID, try to identify by slider configuration or attributes
                            if (!key) {
                                // Use data attributes to identify the slider
                                key = container.getAttribute('data-slider-key') || 
                                      container.getAttribute('data-performance-setting');
                                console.log(`   - From attributes: "${key}"`);
                                
                                // If still no key, generate one based on position and attributes
                                if (!key) {
                                    const performanceSetting = container.getAttribute('data-performance-setting');
                                    if (performanceSetting === 'fps') {
                                        key = 'overlayFpsSlider';
                                    } else if (performanceSetting === 'distance') {
                                        key = 'espDistanceSlider';
                                    }
                                    console.log(`   - Generated from setting: "${key}"`);
                                }
                            }
                            
                            // Fallback to data attribute or index-based key
                            if (!key) {
                                key = container.getAttribute('data-slider-key') || `slider-${index}`;
                                console.log(`   - Fallback key: "${key}"`);
                            }
                            
                            // Enhanced value parsing with validation
                            const parsedValue = parseFloat(value);
                            console.log(`   - Parsed value: ${parsedValue}, isNaN: ${isNaN(parsedValue)}`);
                            if (!isNaN(parsedValue)) {
                                config.ui.sliders[key] = parsedValue;
                                console.log(`   ✅ Saved slider "${key}" = ${parsedValue}`);
                                
                                // Debug logging for performance sliders
                                if (key === 'overlayFpsSlider' || key === 'espDistanceSlider') {
                                    console.log(`💾 Saving performance slider ${key}:`, parsedValue);
                                }
                            } else {
                                console.log(`   ❌ Failed to save slider "${key}" - invalid value: ${value}`);
                            }
                        } else {
                            console.log(`   ❌ No thumb found for slider ${index}`);
                        }
                    });
                    
                    // Save all select states
                    document.querySelectorAll('select').forEach((select, index) => {
                        const key = select.id || select.getAttribute('data-setting') || `select-${index}`;
                        config.ui.selects[key] = select.value;
                    });
                    
                    // Store in localStorage
                    localStorage.setItem('solaraEspConfig', JSON.stringify(config));
                    console.log('=== FULL CONFIG SAVED ===', config);
                    console.log('Toggles saved:', Object.keys(config.ui.toggles));
                    console.log('Colors saved:', Object.keys(config.ui.colors));
                    console.log('Sliders saved:', Object.keys(config.ui.sliders));
                } else {
                    console.log('=== SAVE BLOCKED ===');
                    console.log('   - Force override:', forceOverride);
                    console.log('   - Auto-save enabled:', this.autoSaveEnabled);
                    console.log('   - Loading complete:', this.loadingComplete);
                    console.log('   - Blocking reason:', !forceOverride && (!this.autoSaveEnabled || !this.loadingComplete));
                }
            }
            
            loadSettings() {
                try {
                    const savedConfig = localStorage.getItem('solaraEspConfig');
                    if (savedConfig) {
                        const config = JSON.parse(savedConfig);
                        console.log('=== LOAD SETTINGS DEBUG ===');
                        console.log('Loading configuration:', config);
                        
                        // Restore current tab first
                        if (config.currentTab) {
                            this.currentTab = config.currentTab;
                        }
                        
                        // Restore collapsed sections
                        if (config.collapsedSections) {
                            this.collapsedSections = { ...config.collapsedSections };
                        }
                        
                        // Restore toggle states
                        if (config.ui && config.ui.toggles) {
                            console.log('Restoring toggles:', Object.keys(config.ui.toggles));
                            this.restoreToggles(config.ui.toggles);
                        }
                        
                        // Restore colors
                        if (config.ui && config.ui.colors) {
                            console.log('Restoring colors:', Object.keys(config.ui.colors));
                            Object.entries(config.ui.colors).forEach(([feature, color]) => {
                                // Update ALL color circles with this feature (not just the first one)
                                const circles = document.querySelectorAll(`[data-feature="${feature}"].color-circle`);
                                circles.forEach(circle => {
                                    circle.style.backgroundColor = color;
                                    circle.setAttribute('data-color', color);
                                });
                                if (['skeleton', 'traps', 'cameras'].includes(feature)) {
                                    console.log(`Restored color for ${feature} (${circles.length} circles):`, color);
                                }
                            });
                        }
                        
                        // Enhanced slider restoration with better error handling
                        if (config.ui && config.ui.sliders) {
                            console.log('🔄 Restoring slider values:', config.ui.sliders);
                            Object.entries(config.ui.sliders).forEach(([key, value]) => {
                                let container = null;
                                
                                // Enhanced container lookup strategy
                                container = document.getElementById(key);
                                
                                // Enhanced fallback for performance sliders
                                if (!container) {
                                    if (key === 'overlayFpsSlider') {
                                        const valueDisplay = document.getElementById('overlayFpsValue');
                                        if (valueDisplay) {
                                            container = valueDisplay.closest('.border')?.querySelector('.slider-container') ||
                                                       valueDisplay.parentElement.parentElement.querySelector('.slider-container');
                                        }
                                    } else if (key === 'espDistanceSlider') {
                                        const valueDisplay = document.getElementById('espDistanceValue');
                                        if (valueDisplay) {
                                            container = valueDisplay.closest('.border')?.querySelector('.slider-container') ||
                                                       valueDisplay.parentElement.parentElement.querySelector('.slider-container');
                                        }
                                    }
                                }
                                
                                // Enhanced fallback to data attribute lookup
                                if (!container) {
                                    container = document.querySelector(`[data-slider-key="${key}"]`);
                                }
                                
                                // Final fallback to index-based lookup
                                if (!container && key.startsWith('slider-')) {
                                    const index = parseInt(key.split('-')[1]) || 0;
                                    const containers = document.querySelectorAll('.slider-container');
                                    if (containers[index]) {
                                        container = containers[index];
                                    }
                                }
                                
                                // Enhanced value restoration with validation
                                if (container && !isNaN(value)) {
                                    console.log(`🎛️ Restoring slider ${key} to value:`, value);
                                    
                                    // Validate value is within slider's range
                                    const minVal = parseInt(container.getAttribute('data-min')) || 0;
                                    const maxVal = parseInt(container.getAttribute('data-max')) || 100;
                                    const clampedValue = Math.max(minVal, Math.min(maxVal, value));
                                    
                                    if (clampedValue !== value) {
                                        console.warn(`⚠️ Slider ${key} value ${value} was clamped to ${clampedValue} (range: ${minVal}-${maxVal})`);
                                    }
                                    
                                    this.setSliderValue(container, clampedValue);
                                    
                                    // Debug output for performance sliders
                                    if (key === 'overlayFpsSlider' || key === 'espDistanceSlider') {
                                        console.log(`✅ Performance slider ${key} restored successfully to ${clampedValue}`);
                                    }
                                } else if (!container) {
                                    console.warn(`⚠️ Could not find container for slider: ${key}`);
                                } else {
                                    console.warn(`⚠️ Invalid value for slider ${key}:`, value);
                                }
                            });
                        }
                        
                        // Restore selects
                        if (config.ui && config.ui.selects) {
                            Object.entries(config.ui.selects).forEach(([key, value]) => {
                                const select = document.getElementById(key) || 
                                              document.querySelector(`[data-setting="${key}"]`) ||
                                              document.querySelectorAll('select')[parseInt(key.split('-')[1]) || 0];
                                if (select) {
                                    select.value = value;
                                }
                            });
                        }
                        
                        console.log('Configuration loaded successfully');
                    }
                } catch (error) {
                    console.log('Error loading configuration, starting fresh:', error);
                    // Clear corrupted data
                    localStorage.removeItem('solaraEspConfig');
                }
            }
            
            restoreToggles(togglesData) {
                console.log('=== RESTORE TOGGLES DEBUG ===');
                
                // First pass: restore master toggles
                Object.entries(togglesData).forEach(([key, data]) => {
                    if (data.isMaster) {
                        const toggle = this.findToggleByKey(key, data);
                        if (toggle) {
                            this.setToggleState(toggle, data.state ? 'checked' : 'unchecked');
                            
                            // Handle master toggle UI consequences
                            const group = toggle.getAttribute('data-group');
                            const childContainer = document.querySelector(`.${group}-children`);
                            if (childContainer) {
                                if (data.state) {
                                    childContainer.style.opacity = '1';
                                    childContainer.style.pointerEvents = 'auto';
                                } else {
                                    childContainer.style.opacity = '0.5';
                                    childContainer.style.pointerEvents = 'none';
                                }
                            }
                        }
                    }
                });
                
                // Check if any child toggles need their masters enabled
                const groupsNeedingMasters = new Set();
                Object.entries(togglesData).forEach(([key, data]) => {
                    if (data.isChild && data.state && data.group) {
                        groupsNeedingMasters.add(data.group);
                    }
                });
                
                // Enable masters for groups that have enabled children
                groupsNeedingMasters.forEach(group => {
                    const masterKey = Object.keys(togglesData).find(k => 
                        togglesData[k].group === group && togglesData[k].isMaster
                    );
                    if (masterKey) {
                        const masterToggle = this.findToggleByKey(masterKey, togglesData[masterKey]);
                        if (masterToggle) {
                            console.log(`Auto-enabling master ${group} for child toggles`);
                            this.setToggleState(masterToggle, 'checked');
                            
                            // Update the saved data too
                            togglesData[masterKey].state = true;
                            
                            // Handle master toggle UI consequences
                            const childContainer = document.querySelector(`.${group}-children`);
                            if (childContainer) {
                                childContainer.style.opacity = '1';
                                childContainer.style.pointerEvents = 'auto';
                            }
                        }
                    }
                });
                
                // Second pass: restore child toggles (masters should now be properly enabled)
                Object.entries(togglesData).forEach(([key, data]) => {
                    if (data.isChild) {
                        const toggle = this.findToggleByKey(key, data);
                        if (toggle) {
                            // Check if master is enabled
                            const group = data.group;
                            const masterKey = Object.keys(togglesData).find(k => 
                                togglesData[k].group === group && togglesData[k].isMaster
                            );
                            const masterEnabled = masterKey && togglesData[masterKey].state;
                            
                            if (masterEnabled) {
                                this.setToggleState(toggle, data.state ? 'checked' : 'unchecked');
                                if (['icons-toggle', 'names-toggle', 'trap-esp-toggle', 'camera-esp-toggle', 'traps-duplicate-toggle', 'cameras-duplicate-toggle'].includes(key)) {
                                    console.log(`Restored child toggle ${key}:`, data.state, 'master enabled:', masterEnabled);
                                }
                            } else {
                                this.setToggleState(toggle, 'unchecked');
                                if (['icons-toggle', 'names-toggle', 'trap-esp-toggle', 'camera-esp-toggle', 'traps-duplicate-toggle', 'cameras-duplicate-toggle'].includes(key)) {
                                    console.log(`Child toggle ${key} disabled because master is off`);
                                }
                            }
                        } else {
                            if (['icons-toggle', 'names-toggle', 'trap-esp-toggle', 'camera-esp-toggle', 'traps-duplicate-toggle', 'cameras-duplicate-toggle'].includes(key)) {
                                console.log(`Child toggle NOT FOUND: ${key}`, data);
                            }
                        }
                    }
                });
                
                // Third pass: restore non-master, non-child toggles
                Object.entries(togglesData).forEach(([key, data]) => {
                    if (!data.isMaster && !data.isChild) {
                        const toggle = this.findToggleByKey(key, data);
                        if (toggle) {
                            this.setToggleState(toggle, data.state ? 'checked' : 'unchecked');
                            if (['skeleton-toggle-2'].includes(key)) {
                                console.log(`Restored regular toggle ${key}:`, data.state);
                            }
                        } else {
                            if (['skeleton-toggle-2'].includes(key)) {
                                console.log(`Regular toggle NOT FOUND: ${key}`, data);
                            }
                        }
                    }
                });
            }
            
            findToggleByKey(key, data) {
                // Ultra-detailed debugging for Icons and Names
                if (['icons-toggle', 'names-toggle'].includes(key)) {
                    console.log(`\n=== FIND TOGGLE DEBUG for ${key} ===`);
                    console.log('Looking for key:', key);
                    console.log('With data:', data);
                }
                
                // Try multiple methods to find the toggle - prioritize ID lookup
                let toggle = null;
                
                // Method 1: By exact ID match (should be primary method)
                toggle = document.getElementById(key);
                if (toggle && toggle.classList.contains('toggle-switch')) {
                    if (['icons-toggle', 'names-toggle'].includes(key)) {
                        console.log('Found by ID:', toggle);
                    }
                    return toggle;
                }
                
                // Method 2: If the key ends with '-toggle', try to find by ID or data-feature
                if (key.endsWith('-toggle')) {
                    const baseKey = key.replace('-toggle', '');
                    // Try by exact ID match first
                    toggle = document.getElementById(baseKey + '-toggle');
                    if (toggle && toggle.classList.contains('toggle-switch')) {
                        if (['icons-toggle', 'names-toggle'].includes(key)) {
                            console.log('Found by baseKey + toggle:', toggle);
                        }
                        return toggle;
                    }
                    
                    toggle = document.getElementById(baseKey);
                    if (toggle && toggle.classList.contains('toggle-switch')) {
                        if (['icons-toggle', 'names-toggle'].includes(key)) {
                            console.log('Found by baseKey:', toggle);
                        }
                        return toggle;
                    }
                    
                    // Try by data-feature
                    toggle = document.querySelector(`[data-feature="${baseKey}"].toggle-switch`);
                    if (toggle) {
                        if (['icons-toggle', 'names-toggle'].includes(key)) {
                            console.log('Found by data-feature:', toggle);
                        }
                        return toggle;
                    }
                }
                
                // Method 3: By stored metadata if available
                if (data.id) {
                    toggle = document.getElementById(data.id);
                    if (toggle && toggle.classList.contains('toggle-switch')) {
                        if (['icons-toggle', 'names-toggle'].includes(key)) {
                            console.log('Found by data.id:', toggle);
                        }
                        return toggle;
                    }
                }
                
                // Method 4: By feature attribute
                if (data.feature) {
                    toggle = document.querySelector(`[data-feature="${data.feature}"].toggle-switch`);
                    if (toggle) {
                        if (['icons-toggle', 'names-toggle'].includes(key)) {
                            console.log('Found by data.feature:', toggle);
                        }
                        return toggle;
                    }
                }
                
                // Method 5: By setting attribute
                if (data.setting) {
                    toggle = document.querySelector(`[data-setting="${data.setting}"].toggle-switch`);
                    if (toggle) {
                        if (['icons-toggle', 'names-toggle'].includes(key)) {
                            console.log('Found by data.setting:', toggle);
                        }
                        return toggle;
                    }
                }
                
                // Method 6: By group and master status
                if (data.group && data.isMaster) {
                    toggle = document.querySelector(`[data-group="${data.group}"].master-toggle`);
                    if (toggle) {
                        if (['icons-toggle', 'names-toggle'].includes(key)) {
                            console.log('Found by master group:', toggle);
                        }
                        return toggle;
                    }
                }
                
                // Method 7: By label text matching
                if (data.labelText) {
                    const allToggles = document.querySelectorAll('.toggle-switch');
                    for (let t of allToggles) {
                        const label = t.closest('.flex')?.querySelector('label')?.textContent?.trim();
                        if (label === data.labelText) {
                            if (['icons-toggle', 'names-toggle'].includes(key)) {
                                console.log('Found by label text:', t);
                            }
                            return t;
                        }
                    }
                }
                
                // Method 8: By index (fallback)
                if (typeof data.index === 'number') {
                    const toggles = document.querySelectorAll('.toggle-switch');
                    if (toggles[data.index]) {
                        if (['icons-toggle', 'names-toggle'].includes(key)) {
                            console.log('Found by index:', toggles[data.index]);
                        }
                        return toggles[data.index];
                    }
                }
                
                if (['icons-toggle', 'names-toggle'].includes(key)) {
                    console.log('NOT FOUND - no method worked');
                }
                return null;
            }
            
            saveState() {
                if (this.autoSaveEnabled && this.loadingComplete) {
                    this.saveSettings();
                }
            }
            
            loadCollapsedStates() {
                // Apply saved collapsed states immediately without animation
                Object.entries(this.collapsedSections).forEach(([sectionId, isCollapsed]) => {
                    const content = document.getElementById(`${sectionId}-content`);
                    const indicator = document.querySelector(`[data-collapsible="${sectionId}"] .collapse-indicator`);
                    const container = content?.closest('.border.rounded-lg.p-4');
                    
                    if (content && indicator && isCollapsed) {
                        // Temporarily disable transitions to make changes instant
                        const originalTransition = content.style.transition;
                        const originalIndicatorTransition = indicator.style.transition;
                        
                        content.style.transition = 'none';
                        indicator.style.transition = 'none';
                        
                        content.classList.add('collapsed');
                        indicator.classList.add('collapsed');
                        container?.classList.add('master-container-collapsed');
                        
                        // Force reflow to ensure styles are applied
                        content.offsetHeight;
                        
                        // Restore transitions after a brief delay
                        setTimeout(() => {
                            content.style.transition = originalTransition;
                            indicator.style.transition = originalIndicatorTransition;
                        }, 100);
                    }
                });
            }
            
            initColorPickers() {
                document.querySelectorAll('.color-picker-container').forEach(container => {
                    const colorCircle = container.querySelector('.color-circle');
                    let customPicker = null;
                    
                    // Click on color circle opens custom color picker
                    colorCircle.addEventListener('click', (e) => {
                        e.stopPropagation();
                        
                        // Close any existing color pickers
                        document.querySelectorAll('.custom-color-picker').forEach(picker => picker.remove());
                        
                        // Get current color from data attribute or computed style
                        const currentColor = colorCircle.getAttribute('data-color') || 
                                           colorCircle.style.backgroundColor || 
                                           window.getComputedStyle(colorCircle).backgroundColor;
                        
                        // Convert RGB to hex if needed
                        const hexColor = currentColor.startsWith('#') ? currentColor : this.rgbToHex(...currentColor.match(/\d+/g).map(Number));
                        
                        // Create custom color picker
                        customPicker = this.createCustomColorPicker(container, hexColor);
                        
                        // Position the picker near the color circle
                        const rect = colorCircle.getBoundingClientRect();
                        const pickerWidth = 320;
                        const pickerHeight = 550; // Increased height for transparency and thickness controls
                        
                        let top = rect.bottom + 8;
                        let left = rect.left;
                        
                        // Check if picker would go off the bottom of the screen
                        if (top + pickerHeight > window.innerHeight) {
                            top = rect.top - pickerHeight - 8; // Position above the color circle
                        }
                        
                        // Check if picker would go off the right side of screen
                        if (left + pickerWidth > window.innerWidth) {
                            left = window.innerWidth - pickerWidth - 10;
                        }
                        
                        // Check if picker would go off the left side of screen
                        if (left < 10) {
                            left = 10;
                        }
                        
                        customPicker.style.top = `${Math.max(10, top)}px`;
                        customPicker.style.left = `${left}px`;
                        
                        document.body.appendChild(customPicker);
                    });
                    
                    // Close color picker when clicking outside
                    document.addEventListener('click', (e) => {
                        if (customPicker && !customPicker.contains(e.target) && !colorCircle.contains(e.target)) {
                            customPicker.remove();
                            customPicker = null;
                        }
                    });
                });
            }
            
            createCustomColorPicker(container, currentColor) {
                const picker = document.createElement('div');
                picker.className = 'custom-color-picker';
                
                // Convert hex to HSV for initial values
                const hsv = this.hexToHsv(currentColor);
                
                const initialXPercent = hsv.s; // X = saturation
                const initialYPercent = 100 - hsv.v; // Y = value (inverted)
                
                // Get feature name
                const colorCircle = container.querySelector('.color-circle');
                const feature = colorCircle.getAttribute('data-feature');
                
                picker.innerHTML = `
                    <div class="color-wheel" data-hue="${hsv.h}" data-saturation="${hsv.s}" data-value="${hsv.v}">
                        <div class="color-wheel-pointer" style="left: ${initialXPercent}%; top: ${initialYPercent}%;"></div>
                    </div>
                    <div class="hue-slider">
                        <div class="hue-slider-pointer" style="left: ${(hsv.h / 360) * 100}%;"></div>
                    </div>
                    <div class="color-preview" style="background-color: ${currentColor};"></div>
                    <div class="color-input-group">
                        <input type="text" class="color-input-field" placeholder="#FF0000" value="${currentColor.toUpperCase()}">
                        <input type="number" class="color-input-field" placeholder="R" value="${this.hexToRgb(currentColor).r}" min="0" max="255">
                        <input type="number" class="color-input-field" placeholder="G" value="${this.hexToRgb(currentColor).g}" min="0" max="255">
                        <input type="number" class="color-input-field" placeholder="B" value="${this.hexToRgb(currentColor).b}" min="0" max="255">
                    </div>
                    <div class="color-picker-buttons">
                        <button class="color-picker-btn" data-action="cancel">Cancel</button>
                        <button class="color-picker-btn primary" data-action="apply">Apply</button>
                    </div>
                `;
                
                this.initColorWheelEvents(picker, container);
                return picker;
            }
            
            initColorWheelEvents(picker, container) {
                const wheel = picker.querySelector('.color-wheel');
                const wheelPointer = picker.querySelector('.color-wheel-pointer');
                const hueSlider = picker.querySelector('.hue-slider');
                const huePointer = picker.querySelector('.hue-slider-pointer');
                const preview = picker.querySelector('.color-preview');
                const hexInput = picker.querySelector('.color-input-field[placeholder="#FF0000"]');
                const rInput = picker.querySelector('.color-input-field[placeholder="R"]');
                const gInput = picker.querySelector('.color-input-field[placeholder="G"]');
                const bInput = picker.querySelector('.color-input-field[placeholder="B"]');
                const colorCircle = container.querySelector('.color-circle');
                const colorInput = container.querySelector('.color-input');
                
                const feature = colorCircle.getAttribute('data-feature');
                
                let currentHue = parseFloat(wheel.getAttribute('data-hue'));
                let currentSaturation = parseFloat(wheel.getAttribute('data-saturation'));
                let currentValue = parseFloat(wheel.getAttribute('data-value'));
                
                const updateColor = () => {
                    const color = this.hsvToHex(currentHue, currentSaturation, currentValue);
                    const rgb = this.hexToRgb(color);
                    
                    preview.style.backgroundColor = color;
                    hexInput.value = color.toUpperCase();
                    rInput.value = rgb.r;
                    gInput.value = rgb.g;
                    bInput.value = rgb.b;
                    
                    // Update wheel background with current hue
                    const baseColor = `hsl(${currentHue}, 100%, 50%)`;
                    wheel.style.background = `
                        linear-gradient(to top, rgba(0,0,0,1) 0%, rgba(0,0,0,0) 100%),
                        linear-gradient(to right, rgba(255,255,255,1) 0%, rgba(255,255,255,0) 100%),
                        ${baseColor}
                    `;
                    
                    // Update hue slider pointer
                    huePointer.style.left = `${(currentHue / 360) * 100}%`;
                };
                
                // Color square interaction
                let isDraggingWheel = false;
                const handleWheelMove = (e) => {
                    if (!isDraggingWheel) return;
                    const rect = wheel.getBoundingClientRect();
                    const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
                    const y = Math.max(0, Math.min(rect.height, e.clientY - rect.top));
                    
                    const xPercent = (x / rect.width) * 100;
                    const yPercent = (y / rect.height) * 100;
                    
                    // For HSV square: X = saturation (0-100), Y = value (100-0, inverted)
                    currentSaturation = xPercent;
                    currentValue = 100 - yPercent; // Inverted: top = bright, bottom = dark
                    
                    wheelPointer.style.left = `${xPercent}%`;
                    wheelPointer.style.top = `${yPercent}%`;
                    updateColor();
                };
                
                wheel.addEventListener('mousedown', (e) => {
                    isDraggingWheel = true;
                    handleWheelMove(e);
                    document.addEventListener('mousemove', handleWheelMove);
                    document.addEventListener('mouseup', () => {
                        isDraggingWheel = false;
                        document.removeEventListener('mousemove', handleWheelMove);
                    }, { once: true });
                });
                
                // Hue slider interaction
                let isDraggingHue = false;
                const handleHueMove = (e) => {
                    if (!isDraggingHue) return;
                    const rect = hueSlider.getBoundingClientRect();
                    const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
                    const percentage = (x / rect.width) * 100;
                    
                    currentHue = Math.max(0, Math.min(360, (percentage / 100) * 360));
                    huePointer.style.left = `${percentage}%`;
                    updateColor();
                };
                
                hueSlider.addEventListener('mousedown', (e) => {
                    isDraggingHue = true;
                    handleHueMove(e);
                    document.addEventListener('mousemove', handleHueMove);
                    document.addEventListener('mouseup', () => {
                        isDraggingHue = false;
                        document.removeEventListener('mousemove', handleHueMove);
                    }, { once: true });
                });
                
                // Input field changes
                hexInput.addEventListener('input', (e) => {
                    const hex = e.target.value;
                    if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                        const hsv = this.hexToHsv(hex);
                        currentHue = hsv.h;
                        currentSaturation = hsv.s;
                        currentValue = hsv.v;
                        
                        const xPercent = currentSaturation;
                        const yPercent = 100 - currentValue;
                        
                        wheelPointer.style.left = `${xPercent}%`;
                        wheelPointer.style.top = `${yPercent}%`;
                        huePointer.style.left = `${(currentHue / 360) * 100}%`;
                        updateColor();
                    }
                });
                
                [rInput, gInput, bInput].forEach(input => {
                    input.addEventListener('input', () => {
                        const r = parseInt(rInput.value) || 0;
                        const g = parseInt(gInput.value) || 0;
                        const b = parseInt(bInput.value) || 0;
                        
                        const hex = this.rgbToHex(r, g, b);
                        const hsv = this.hexToHsv(hex);
                        
                        currentHue = hsv.h;
                        currentSaturation = hsv.s;
                        currentValue = hsv.v;
                        
                        const xPercent = currentSaturation;
                        const yPercent = 100 - currentValue;
                        
                        wheelPointer.style.left = `${xPercent}%`;
                        wheelPointer.style.top = `${yPercent}%`;
                        huePointer.style.left = `${(currentHue / 360) * 100}%`;
                        updateColor();
                    });
                });
                
                // Button actions
                picker.querySelector('[data-action="cancel"]').addEventListener('click', () => {
                    picker.remove();
                });
                
                picker.querySelector('[data-action="apply"]').addEventListener('click', () => {
                    const finalColor = this.hsvToHex(currentHue, currentSaturation, currentValue);
                    
                    // Update ALL color circles with the same feature (not just this one)
                    if (feature) {
                        const allCircles = document.querySelectorAll(`[data-feature="${feature}"].color-circle`);
                        allCircles.forEach(circle => {
                            circle.style.backgroundColor = finalColor;
                            circle.setAttribute('data-color', finalColor);
                            
                            // Update indicator dots for each circle
                            const indicatorDot = circle.closest('.flex.items-center.justify-between')?.querySelector('.w-2.h-2');
                            if (indicatorDot) {
                                indicatorDot.style.backgroundColor = finalColor;
                            }
                        });
                    } else {
                        // Fallback: just update the single circle if no feature
                        colorCircle.style.backgroundColor = finalColor;
                        colorCircle.setAttribute('data-color', finalColor);
                        
                        const indicatorDot = colorCircle.closest('.flex.items-center.justify-between')?.querySelector('.w-2.h-2');
                        if (indicatorDot) {
                            indicatorDot.style.backgroundColor = finalColor;
                        }
                    }
                    
                    this.saveSettings();
                    this.saveState(); // Auto-save color changes
                    this.showToast(`${feature || 'Color'} updated`, 'success');
                    picker.remove();
                });
                
                // Initialize the color wheel appearance
                updateColor();
            }
            
            // Color conversion utilities
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }
            
            rgbToHex(r, g, b) {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }
            
            hexToHsv(hex) {
                const rgb = this.hexToRgb(hex);
                return this.rgbToHsv(rgb.r, rgb.g, rgb.b);
            }
            
            rgbToHsv(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const diff = max - min;
                
                let h = 0;
                if (diff !== 0) {
                    if (max === r) h = ((g - b) / diff) % 6;
                    else if (max === g) h = (b - r) / diff + 2;
                    else h = (r - g) / diff + 4;
                }
                h = Math.round(h * 60);
                if (h < 0) h += 360;
                
                const s = max === 0 ? 0 : Math.round((diff / max) * 100);
                const v = Math.round(max * 100);
                
                return { h, s, v };
            }
            
            hsvToHex(h, s, v) {
                s /= 100;
                v /= 100;
                
                const c = v * s;
                const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
                const m = v - c;
                
                let r = 0, g = 0, b = 0;
                
                if (h >= 0 && h < 60) {
                    r = c; g = x; b = 0;
                } else if (h >= 60 && h < 120) {
                    r = x; g = c; b = 0;
                } else if (h >= 120 && h < 180) {
                    r = 0; g = c; b = x;
                } else if (h >= 180 && h < 240) {
                    r = 0; g = x; b = c;
                } else if (h >= 240 && h < 300) {
                    r = x; g = 0; b = c;
                } else if (h >= 300 && h < 360) {
                    r = c; g = 0; b = x;
                }
                
                r = Math.round((r + m) * 255);
                g = Math.round((g + m) * 255);
                b = Math.round((b + m) * 255);
                
                return this.rgbToHex(r, g, b);
            }
            
            // Feature transparency and thickness management
            getFeatureTransparency(feature) {
                if (!feature) return 85;
                const config = JSON.parse(localStorage.getItem('solaraEspConfig') || '{}');
                return config.transparency?.[feature] || 85;
            }
            
            setFeatureTransparency(feature, value) {
                if (!feature) return;
                const config = JSON.parse(localStorage.getItem('solaraEspConfig') || '{}');
                if (!config.transparency) config.transparency = {};
                config.transparency[feature] = Math.round(value);
                localStorage.setItem('solaraEspConfig', JSON.stringify(config));
            }
            
            getFeatureThickness(feature) {
                if (!feature) return 2;
                const config = JSON.parse(localStorage.getItem('solaraEspConfig') || '{}');
                return config.thickness?.[feature] || 2;
            }
            
            setFeatureThickness(feature, value) {
                if (!feature) return;
                const config = JSON.parse(localStorage.getItem('solaraEspConfig') || '{}');
                if (!config.thickness) config.thickness = {};
                config.thickness[feature] = Math.round(value);
                localStorage.setItem('solaraEspConfig', JSON.stringify(config));
            }
            
            featureSupportsThickness(feature) {
                // Features that make sense to have thickness controls
                const thicknessFeatures = [
                    'skeleton', 'box', 'health', 'traps', 'cameras', 'drones', 
                    'destructibles', 'breaching', 'boundingbox', 'headcircle', 
                    'skeleton-alt', 'throwables'
                ];
                return thicknessFeatures.includes(feature);
            }
            
            setSliderValue(sliderContainer, value) {
                const thumb = sliderContainer.querySelector('.slider-thumb');
                const fill = sliderContainer.querySelector('.slider-fill');
                
                if (!thumb || !fill) {
                    console.warn('setSliderValue failed: Missing slider elements');
                    return;
                }
                
                // Get slider-specific configuration and state
                const config = sliderContainer._sliderConfig || {
                    minValue: parseInt(sliderContainer.getAttribute('data-min')) || 0,
                    maxValue: parseInt(sliderContainer.getAttribute('data-max')) || 100,
                    step: parseInt(sliderContainer.getAttribute('data-step')) || 1,
                    precision: parseInt(sliderContainer.getAttribute('data-precision')) || 0
                };
                
                if (!sliderContainer._sliderConfig) {
                    config.range = config.maxValue - config.minValue;
                    config.sliderId = sliderContainer.id;
                }
                
                // Get slider-specific value display - TRULY UNIQUE to this slider
                let valueDisplay = null;
                
                // Use slider ID to find the correct corresponding value display
                if (config.sliderId === 'overlayFpsSlider') {
                    valueDisplay = document.querySelector('#overlayFpsValue');
                } else if (config.sliderId === 'espDistanceSlider') {
                    valueDisplay = document.querySelector('#espDistanceValue');
                } else {
                    // Fallback to closest value display for other sliders
                    valueDisplay = sliderContainer.closest('.border').querySelector('.slider-value') ||
                                   sliderContainer.closest('.border').querySelector('[id$="Value"]');
                }
                
                // Enhanced value processing with step and precision - ISOLATED
                const steppedValue = Math.round(value / config.step) * config.step;
                const clampedValue = Math.max(config.minValue, Math.min(config.maxValue, steppedValue));
                const percentage = ((clampedValue - config.minValue) / config.range) * 100;
                
                // Enhanced value formatting - SPECIFIC to this slider
                const formatDisplayValue = (val) => {
                    const finalVal = config.precision > 0 ? 
                        parseFloat(val.toFixed(config.precision)) : 
                        Math.round(val);
                        
                    // Use ONLY slider ID for formatting to avoid cross-contamination
                    if (config.sliderId === 'overlayFpsSlider') {
                        return `${finalVal} FPS`;
                    } else if (config.sliderId === 'espDistanceSlider') {
                        return `${finalVal}m`;
                    } else {
                        return `${finalVal}%`;
                    }
                };
                
                // Update internal state if available
                if (sliderContainer._sliderState) {
                    sliderContainer._sliderState.currentValue = clampedValue;
                }
                
                // Smooth visual updates with enhanced transitions - TARGET ONLY THIS SLIDER
                thumb.style.transition = 'left 0.2s cubic-bezier(0.4, 0, 0.2, 1)';
                fill.style.transition = 'width 0.2s cubic-bezier(0.4, 0, 0.2, 1)';
                
                thumb.style.left = `${percentage}%`;
                fill.style.width = `${percentage}%`;
                
                // Enhanced value display updates - UPDATE ONLY THIS SLIDER'S DISPLAY
                if (valueDisplay) {
                    const newDisplayValue = formatDisplayValue(clampedValue);
                    valueDisplay.textContent = newDisplayValue;
                    
                    // Add subtle scale animation for visual feedback - ONLY this display
                    valueDisplay.style.transition = 'transform 0.15s ease';
                    valueDisplay.style.transform = 'scale(1.02)';
                    setTimeout(() => {
                        if (valueDisplay) { // Safety check
                            valueDisplay.style.transform = 'scale(1)';
                        }
                    }, 150);
                }
                
                // Enhanced ARIA attributes for better accessibility - UPDATE ONLY THIS SLIDER
                thumb.setAttribute('aria-valuenow', clampedValue);
                thumb.setAttribute('aria-valuemin', config.minValue);
                thumb.setAttribute('aria-valuemax', config.maxValue);
                thumb.setAttribute('aria-valuetext', formatDisplayValue(clampedValue));
                sliderContainer.setAttribute('data-value', clampedValue);
                
                // Debug logging for verification
                console.log(`🎯 setSliderValue: ${config.sliderId || 'unknown'} set to ${clampedValue} (${formatDisplayValue(clampedValue)})`);
                
                // Clear transitions after animation
                setTimeout(() => {
                    thumb.style.transition = '';
                    fill.style.transition = '';
                }, 200);
                
                return clampedValue;
            }
            
            showToast(message, type = 'info') {
                // Remove any existing toasts
                document.querySelectorAll('.toast-notification').forEach(existingToast => {
                    existingToast.remove();
                });
                
                const toast = document.createElement('div');
                toast.className = `toast-notification rounded-lg border p-4 shadow-lg ${
                    type === 'success' ? 'bg-green-50 border-green-200 text-green-800 dark:bg-green-950 dark:border-green-800 dark:text-green-200' :
                    type === 'error' ? 'bg-red-50 border-red-200 text-red-800 dark:bg-red-950 dark:border-red-800 dark:text-red-200' :
                    'bg-blue-50 border-blue-200 text-blue-800 dark:bg-blue-950 dark:border-blue-800 dark:text-blue-200'
                }`;
                
                // Ensure high z-index and proper positioning with inline styles
                toast.style.cssText = `
                    position: fixed !important;
                    top: 64px !important;
                    right: 16px !important;
                    z-index: 9999 !important;
                    transform: translateX(100%);
                    transition: transform 0.3s ease-in-out;
                    max-width: 300px;
                `;
                
                toast.innerHTML = `
                    <div class="flex items-center gap-2">
                        <span class="text-sm font-medium">${message}</span>
                        <button onclick="this.parentElement.parentElement.remove()" class="ml-2 text-xs opacity-70 hover:opacity-100">✕</button>
                    </div>
                `;
                
                document.body.appendChild(toast);
                
                // Animate slide in from right
                setTimeout(() => {
                    toast.style.transform = 'translateX(0)';
                }, 10);
                
                // Auto dismiss with slide out animation
                setTimeout(() => {
                    if (toast.parentElement) {
                        toast.style.transform = 'translateX(100%)';
                        setTimeout(() => {
                            if (toast.parentElement) {
                                toast.remove();
                            }
                        }, 300);
                    }
                }, 3000);
            }
            
            initPerformanceFeatures() {
                // Performance features are now handled by the standard slider system
                // No additional setup needed
            }
            
            startPerformanceMonitoring() {
                const currentFpsElement = document.getElementById('currentFps');
                const espObjectsElement = document.getElementById('espObjects');
                
                if (currentFpsElement && espObjectsElement) {
                    setInterval(() => {
                        // Simulate FPS counter
                        const fps = Math.floor(Math.random() * 20) + 140; // 140-160 FPS
                        currentFpsElement.textContent = fps;
                        
                        // Simulate ESP object count
                        const objects = Math.floor(Math.random() * 15) + 5; // 5-20 objects
                        espObjectsElement.textContent = objects;
                    }, 1000);
                }
            }
            
            initTabSlider() {
                const slider = document.getElementById('tabSlider');
                const tabs = document.querySelectorAll('.settings-tab');
                
                if (slider && tabs.length > 0) {
                    // Position slider on the active tab initially
                    this.updateTabSlider();
                }
            }
            
            updateTabSlider() {
                const slider = document.getElementById('tabSlider');
                const activeTab = document.querySelector('.settings-tab.active');
                const container = document.querySelector('.tab-container');
                
                if (slider && activeTab && container) {
                    const containerRect = container.getBoundingClientRect();
                    const tabRect = activeTab.getBoundingClientRect();
                    
                    // Calculate position relative to container
                    const relativeTop = tabRect.top - containerRect.top;
                    
                    // Position slider to match the active tab
                    slider.style.transform = `translateY(${relativeTop}px)`;
                    slider.style.height = `${tabRect.height}px`;
                }
            }
            
            initCollapsibleSections() {
                // Add click handlers for collapsible sections
                document.querySelectorAll('[data-collapsible]').forEach(header => {
                    header.addEventListener('click', (e) => {
                        if (e.target.closest('.toggle-switch')) return; // Don't collapse when clicking toggle
                        
                        const sectionId = header.getAttribute('data-collapsible');
                        const content = document.getElementById(`${sectionId}-content`);
                        const indicator = header.querySelector('.collapse-indicator');
                        const container = content?.closest('.border.rounded-lg.p-4');
                        
                        if (content && indicator) {
                            const isCollapsed = content.classList.contains('collapsed');
                            
                            if (isCollapsed) {
                                // Expanding
                                content.classList.remove('collapsed');
                                indicator.classList.remove('collapsed');
                                container?.classList.remove('master-container-collapsed');
                                this.collapsedSections[sectionId] = false;
                            } else {
                                // Collapsing - same speed as expanding
                                content.classList.add('collapsed');
                                indicator.classList.add('collapsed');
                                container?.classList.add('master-container-collapsed');
                                this.collapsedSections[sectionId] = true;
                            }
                            
                            this.saveState();
                        }
                    });
                });
            }
            
            initMasterToggles() {
                // Enhanced master toggle logic for each ESP group
                document.querySelectorAll('.master-toggle').forEach(masterToggle => {
                    const groupName = masterToggle.getAttribute('data-group');
                    
                    masterToggle.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent collapsible trigger
                        
                        const isChecked = masterToggle.getAttribute('data-state') === 'checked';
                        const newState = isChecked ? 'unchecked' : 'checked';
                        
                        // Update master toggle
                        this.setToggleState(masterToggle, newState);
                        
                        // Update children container
                        const childrenContainer = document.querySelector(`.${groupName}-children`);
                        if (childrenContainer) {
                            if (newState === 'checked') {
                                childrenContainer.style.opacity = '1';
                                childrenContainer.style.pointerEvents = 'auto';
                            } else {
                                childrenContainer.style.opacity = '0.5';
                                childrenContainer.style.pointerEvents = 'none';
                                
                                // Turn off all child toggles
                                childrenContainer.querySelectorAll('.child-toggle').forEach(childToggle => {
                                    this.setToggleState(childToggle, 'unchecked');
                                });
                            }
                        }
                        
                        this.saveSettings();
                        this.saveState(); // Auto-save master toggle state
                        this.showToast(`${groupName.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase())} ${newState === 'checked' ? 'enabled' : 'disabled'}`, 'success');
                    });
                });
            }
            
            updateGadgetToggles() {
                // Add data-group attributes to gadget ESP toggles
                const gadgetContainer = document.querySelector('.gadget-esp-children');
                if (gadgetContainer) {
                    gadgetContainer.querySelectorAll('.toggle-switch:not(.master-toggle)').forEach(toggle => {
                        if (!toggle.hasAttribute('data-group')) {
                            toggle.setAttribute('data-group', 'gadget-esp');
                            toggle.classList.add('child-toggle');
                        }
                    });
                }
            }
            
            updateEnvironmentToggles() {
                // Add data-group attributes to environment ESP toggles
                const environmentContainer = document.querySelector('.environment-esp-children');
                if (environmentContainer) {
                    environmentContainer.querySelectorAll('.toggle-switch:not(.master-toggle)').forEach(toggle => {
                        if (!toggle.hasAttribute('data-group')) {
                            toggle.setAttribute('data-group', 'environment-esp');
                            toggle.classList.add('child-toggle');
                        }
                    });
                }
            }
            
            addMissingFeatureAttributes() {
                // Automatically add data-feature attributes to toggles based on their associated color circles
                document.querySelectorAll('.toggle-switch').forEach(toggle => {
                    // Skip if already has data-feature
                    if (toggle.getAttribute('data-feature')) return;
                    
                    // Find the color circle in the same container
                    const container = toggle.closest('.flex.items-center.justify-between');
                    if (container) {
                        const colorCircle = container.querySelector('.color-circle[data-feature]');
                        if (colorCircle) {
                            const feature = colorCircle.getAttribute('data-feature');
                            toggle.setAttribute('data-feature', feature);
                        }
                    }
                });
            }
            
            addMissingFeatureAttributes() {
                // Automatically add data-feature attributes to toggles based on their associated color circles
                document.querySelectorAll('.toggle-switch').forEach(toggle => {
                    // Skip if already has data-feature
                    if (toggle.getAttribute('data-feature')) return;
                    
                    // Find the color circle in the same container
                    const container = toggle.closest('.flex.items-center.justify-between');
                    if (container) {
                        const colorCircle = container.querySelector('.color-circle[data-feature]');
                        if (colorCircle) {
                            const feature = colorCircle.getAttribute('data-feature');
                            toggle.setAttribute('data-feature', feature);
                        }
                    }
                });
            }
            
            setToggleState(toggleElement, state) {
                toggleElement.setAttribute('data-state', state);
                toggleElement.setAttribute('aria-checked', state === 'checked');
                
                const thumb = toggleElement.querySelector('.toggle-thumb');
                thumb.setAttribute('data-state', state);
                
                // Update classes for visual state
                if (state === 'checked') {
                    toggleElement.classList.add('bg-primary');
                    toggleElement.classList.remove('bg-input');
                    thumb.style.transform = 'translateX(16px)';
                } else {
                    toggleElement.classList.remove('bg-primary');
                    toggleElement.classList.add('bg-input');
                    thumb.style.transform = 'translateX(0)';
                }
            }
        }
        
        // Global page transition functions
        function navigateToLoader() {
            const transition = document.getElementById('pageTransition');
            const content = document.getElementById('pageContent');
            
            // Start fade out
            content.style.opacity = '0';
            transition.style.opacity = '1';
            transition.style.pointerEvents = 'all';
            
            // Navigate after fade out completes
            setTimeout(() => {
                window.location.href = '../index.html';
            }, 400);
        }
        
        function initPageTransition() {
            const transition = document.getElementById('pageTransition');
            const content = document.getElementById('pageContent');
            
            let appLoaded = false;
            let pageLoaded = false;
            
            const checkAndFadeIn = () => {
                if (appLoaded && pageLoaded) {
                    setTimeout(() => {
                        transition.style.opacity = '0';
                        content.style.opacity = '1';
                        setTimeout(() => {
                            transition.style.pointerEvents = 'none';
                        }, 400);
                    }, 100);
                }
            };
            
            // Listen for menu app loaded event
            window.addEventListener('menuAppLoaded', () => {
                appLoaded = true;
                checkAndFadeIn();
            });
            
            // Ensure page is fully loaded before fading in
            window.addEventListener('load', () => {
                pageLoaded = true;
                checkAndFadeIn();
            });
            
            // Also handle DOMContentLoaded as fallback
            if (document.readyState === 'complete') {
                pageLoaded = true;
                checkAndFadeIn();
            }
            
            // Initialize menu app
            new MenuApp();
        }
        
        // Initialize everything
        document.addEventListener('DOMContentLoaded', () => {
            initPageTransition();
        });
    </script>
</body>
</html>
